<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Dino Run - Universal Fit</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap');

        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #1a1a1a; /* Dark background for letterboxing */
            font-family: 'Fredoka One', cursive;
            overflow: hidden;
            touch-action: none;
        }

        /* The container fills the screen */
        #game-container {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        /* The Canvas scales to fit inside the container without stretching */
        canvas {
            display: block;
            max-width: 100%;
            max-height: 100%;
            /* This ensures 16:9 ratio is preserved */
            aspect-ratio: 16/9; 
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            background-color: #4AC;
        }

        /* Loading Overlay */
        #loader {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: #fff;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            transition: opacity 0.4s;
        }

        h1 { margin: 0 0 20px 0; color: #333; font-size: 5vw; letter-spacing: 2px; }
        @media (min-width: 800px) { h1 { font-size: 40px; } }

        #progress-bar {
            width: 50%;
            max-width: 400px;
            height: 15px;
            background: #eee;
            border-radius: 10px;
            overflow: hidden;
        }
        #progress-fill {
            height: 100%;
            width: 0%;
            background: #ff8800;
            transition: width 0.1s linear;
        }

        /* Mobile Controls - Fixed to Screen Corners */
        #mobile-controls {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            height: 0; /* Don't block center screen */
            display: none; /* JS enables this */
            z-index: 50;
        }

        .control-btn {
            position: absolute;
            bottom: 10px;
            width: 90px;
            height: 90px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 40px;
            color: white;
            user-select: none;
            backdrop-filter: blur(4px);
            /* Disable tap highlight color */
            -webkit-tap-highlight-color: transparent;
        }

        /* Left Corner */
        #btn-duck { left: 20px; }
        
        /* Right Corner */
        #btn-jump { right: 20px; }

        .control-btn:active {
            background: rgba(255, 255, 255, 0.5);
            transform: scale(0.9);
        }
    </style>
</head>
<body>

<div id="game-container">
    <div id="loader">
        <h1>DINO RUN</h1>
        <div id="progress-bar"><div id="progress-fill"></div></div>
    </div>
    
    <!-- Controls overlay on top of everything -->
    <div id="mobile-controls">
        <div id="btn-duck" class="control-btn">⬇️</div>
        <div id="btn-jump" class="control-btn">⬆️</div>
    </div>

    <!-- Canvas resolution fixed at 800x450 for logic, CSS handles scaling -->
    <canvas id="gameCanvas" width="800" height="450"></canvas>
</div>

<script>
/**
 * DINO RUN - UNIVERSAL FIT
 * 
 * 1. CSS Aspect-Ratio: Canvas scales to fit viewport perfectly.
 * 2. Controls: Corner-based touch buttons for tablets/phones.
 * 3. Gameplay: Challenging Pro physics preserved.
 */

const ASSETS_SRC = {
    bg: "https://github.com/Rajacajustin/gs_1/blob/main/dr_ge_1/dr_ge_1_as/dr_ge_1_as_bgs/dr_ge_1_as_bgs_1/bg_2.png?raw=true",
    ground: "https://github.com/Rajacajustin/gs_1/blob/main/dr_ge_1/dr_ge_1_as/dr_ge_1_as_gs/dr_ge_1_as_gs_1/gd_1.png?raw=true",
    cactus: "https://github.com/Rajacajustin/gs_1/blob/main/dr_ge_1/dr_ge_1_as/dr_ge_1_as_os/dr_ge_1_as_os_1/cs_1.png?raw=true",
    btnPlay: "https://github.com/Rajacajustin/gs_1/blob/main/as/as_ui/as_ui_1/as_ui_1_ui_bs_1/py_ne_ui_bn.png?raw=true",
    btnReplay: "https://github.com/Rajacajustin/gs_1/blob/main/as/as_ui/as_ui_1/as_ui_1_ui_bs_1/ry_ne_ui_bn.png?raw=true",
    
    idle: Array.from({length:10}, (_,i)=> `https://github.com/Rajacajustin/gs_1/blob/main/dr_ge_1/dr_ge_1_as/dr_ge_1_as_dr/dr_ge_1_as_dr_1/dr_le_${i+1}.png?raw=true`),
    run: Array.from({length:8}, (_,i)=> `https://github.com/Rajacajustin/gs_1/blob/main/dr_ge_1/dr_ge_1_as/dr_ge_1_as_dr/dr_ge_1_as_dr_1/dr_rn_${i+1}.png?raw=true`),
    jump: Array.from({length:12}, (_,i)=> `https://github.com/Rajacajustin/gs_1/blob/main/dr_ge_1/dr_ge_1_as/dr_ge_1_as_dr/dr_ge_1_as_dr_1/dr_jp_${i+1}.png?raw=true`),
    dead: Array.from({length:8}, (_,i)=> `https://github.com/Rajacajustin/gs_1/blob/main/dr_ge_1/dr_ge_1_as/dr_ge_1_as_dr/dr_ge_1_as_dr_1/dr_dd_${i+1}.png?raw=true`),
    bird: Array.from({length:4}, (_,i)=> `https://github.com/Rajacajustin/gs_1/blob/main/dr_ge_1/dr_ge_1_as/dr_ge_1_as_os/dr_ge_1_as_os_1/dr_ge_1_as_os_1_bds_1/be_bd_${i+1}.png?raw=true`),
    
    sndJump: "https://github.com/Rajacajustin/gs_1/raw/refs/heads/main/dr_ge_1/dr_ge_1_as/dr_ge_1_as_sd_es/dr_ge_1_as_sd_es_1/jp_sd_et.mp3",
    sndDuck: "https://github.com/Rajacajustin/gs_1/raw/refs/heads/main/dr_ge_1/dr_ge_1_as/dr_ge_1_as_sd_es/dr_ge_1_as_sd_es_1/wh_sd_et.mp3",
    sndDie: "https://github.com/Rajacajustin/gs_1/raw/refs/heads/main/se_ge_1/se_ge_1_as/se_ge_1_as_sd_es/se_ge_1_as_sd_es_1/ge_or_sd_et_.mp3"
};

const CONFIG = {
    startSpeed: 10,     
    gravity: 0.7,
    jumpForce: -14,
    groundH: 80,
    dinoSize: 85,
    duckDuration: 45
};

// --- GLOBALS ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const loader = document.getElementById('loader');
const progress = document.getElementById('progress-fill');

let assets = {};
let sounds = {};
let gameState = "INIT"; 
let score = 0;
let highScore = localStorage.getItem('dino_score_universal') || 0;
let speed = CONFIG.startSpeed;
let frames = 0;

let dino = { x: 50, y: 0, vy: 0, state: "IDLE", frame: 0 };
let obstacles = [];
let groundOffset = 0;
let input = { up: false, down: false };
let duckTimer = 0;
let inputLockDuck = false;

// Determine Mobile
let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
let ui = { flashOp: 0, textY: -100, boardY: 600, targetBoardY: 150, pulse: 1 };

if(isMobile) {
    document.getElementById('mobile-controls').style.display = 'block';
    
    const btnJump = document.getElementById('btn-jump');
    const btnDuck = document.getElementById('btn-duck');

    // JUMP Event
    const triggerJump = (e) => {
        if(e.cancelable) e.preventDefault();
        if(gameState === "PLAY") input.up = true;
        else checkClick();
    };
    btnJump.addEventListener('touchstart', triggerJump, {passive:false});
    btnJump.addEventListener('touchend', (e) => { e.preventDefault(); input.up = false; });

    // DUCK Event
    const triggerDuck = (e) => {
        if(e.cancelable) e.preventDefault();
        input.down = true;
    };
    btnDuck.addEventListener('touchstart', triggerDuck, {passive:false});
    btnDuck.addEventListener('touchend', (e) => { e.preventDefault(); input.down = false; });
}

async function init() {
    let toLoad = [];
    const add = (k, s) => toLoad.push({k, s});
    
    add('bg', ASSETS_SRC.bg); add('ground', ASSETS_SRC.ground);
    add('cactus', ASSETS_SRC.cactus); add('btnPlay', ASSETS_SRC.btnPlay);
    add('btnReplay', ASSETS_SRC.btnReplay);
    
    ASSETS_SRC.idle.forEach((s, i)=> add(`idle_${i}`, s));
    ASSETS_SRC.run.forEach((s, i)=> add(`run_${i}`, s));
    ASSETS_SRC.jump.forEach((s, i)=> add(`jump_${i}`, s));
    ASSETS_SRC.dead.forEach((s, i)=> add(`dead_${i}`, s));
    ASSETS_SRC.bird.forEach((s, i)=> add(`bird_${i}`, s));

    let loaded = 0;
    const promise = (item) => new Promise(res => {
        const img = new Image();
        img.src = item.s;
        img.onload = () => {
            loaded++;
            progress.style.width = (loaded/toLoad.length * 100) + "%";
            res({k:item.k, img});
        };
        img.onerror = () => res({k:item.k, img:null});
    });

    const results = await Promise.all(toLoad.map(promise));
    
    assets.idle=[]; assets.run=[]; assets.jump=[]; assets.dead=[]; assets.bird=[];
    results.forEach(({k, img}) => {
        if(k.includes('_')) {
            const [type, idx] = k.split('_');
            assets[type][parseInt(idx)] = img;
        } else {
            assets[k] = img;
        }
    });

    sounds.jump = new Audio(ASSETS_SRC.sndJump);
    sounds.duck = new Audio(ASSETS_SRC.sndDuck);
    sounds.die = new Audio(ASSETS_SRC.sndDie);

    setTimeout(() => {
        loader.style.opacity = 0;
        setTimeout(() => loader.remove(), 500);
        goHome();
        loop();
    }, 500);
}

function goHome() {
    gameState = "HOME";
    resetGame();
    ui.flashOp = 0; ui.textY = -100; ui.boardY = canvas.height + 200;
}

function startGame() {
    gameState = "PLAY";
    resetGame();
    sounds.jump.play().catch(()=>{});
}

function resetGame() {
    // DINO: kept sunken as requested
    dino.y = canvas.height - CONFIG.groundH - CONFIG.dinoSize + 10; 
    dino.vy = 0;
    dino.state = "RUN"; 
    obstacles = [];
    score = 0;
    speed = CONFIG.startSpeed;
    frames = 0;
    groundOffset = 0;
    duckTimer = 0;
    inputLockDuck = false;
}

function update() {
    ui.pulse = 1 + Math.sin(frames * 0.1) * 0.05;

    if (gameState === "HOME") {
        frames++;
        dino.state = "IDLE";
    } 
    else if (gameState === "PLAY") {
        frames++;
        score++;
        speed += 0.003; 
        groundOffset = (groundOffset + speed) % assets.ground.width;
        
        const groundTop = canvas.height - CONFIG.groundH;
        const floor = groundTop - CONFIG.dinoSize + 10;

        dino.y += dino.vy;

        if (dino.y >= floor) {
            dino.y = floor;
            dino.vy = 0;

            // Auto Release Duck
            if (duckTimer > 0) {
                dino.state = "DUCK";
                duckTimer--;
                if(duckTimer <= 0) dino.state = "RUN"; 
            } else {
                dino.state = "RUN";
            }

            if (input.up) {
                dino.vy = CONFIG.jumpForce;
                dino.state = "JUMP";
                duckTimer = 0;
                sounds.jump.currentTime = 0;
                sounds.jump.play().catch(()=>{});
                input.up = false;
            } 
            else if (input.down) {
                if (!inputLockDuck && duckTimer <= 0) {
                    duckTimer = CONFIG.duckDuration;
                    dino.state = "DUCK";
                    sounds.duck.currentTime = 0;
                    sounds.duck.play().catch(()=>{});
                    inputLockDuck = true;
                }
            } else {
                inputLockDuck = false;
            }

        } else {
            dino.vy += CONFIG.gravity;
            dino.state = "JUMP";
            if(input.down) dino.vy += 1.5;
        }

        manageObstacles();
    }
    else if (gameState === "DYING") {
        frames++;
        const groundTop = canvas.height - CONFIG.groundH;
        const floor = groundTop - CONFIG.dinoSize + 10;
        
        if (dino.y < floor) dino.y += CONFIG.gravity * 2;
        else dino.y = floor;

        if (dino.frame < assets.dead.length - 1) {
            if (frames % 4 === 0) dino.frame++;
        } else {
            gameState = "GAMEOVER";
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('dino_score_universal', highScore);
            }
        }
    }
    else if (gameState === "GAMEOVER") {
        const floor = canvas.height - CONFIG.groundH - CONFIG.dinoSize + 10;
        if (dino.y < floor) dino.y += CONFIG.gravity * 2;

        if(ui.flashOp > 0) ui.flashOp -= 0.03;
        if(ui.textY < 80) ui.textY += (80 - ui.textY) * 0.1;
        if(ui.boardY > ui.targetBoardY) ui.boardY += (ui.targetBoardY - ui.boardY) * 0.1;
    }
}

function manageObstacles() {
    if (frames % Math.floor(90 - speed) === 0 && frames > 30) {
        if(Math.random() > 0.3) {
            if(obstacles.length === 0 || canvas.width - obstacles[obstacles.length-1].x > 250) {
                let type = Math.random() > 0.6 ? "BIRD" : "CACTUS";
                let obs = {type, x:canvas.width, y:0, w:0, h:0, frame:0};
                
                const groundTop = canvas.height - CONFIG.groundH;

                if(type === "CACTUS") {
                    obs.w = 50; obs.h = 60;
                    // CACTUS: Exactly on top line
                    obs.y = groundTop - obs.h; 
                } else {
                    obs.w = 50; obs.h = 40;
                    let isHigh = Math.random() > 0.5;
                    if (isHigh) obs.y = groundTop - 85; 
                    else obs.y = groundTop - 50; 
                }
                obstacles.push(obs);
            }
        }
    }

    for (let i = obstacles.length - 1; i >= 0; i--) {
        let o = obstacles[i];
        o.x -= speed;
        if(o.type === "BIRD" && frames % 10 === 0) o.frame++;

        if (checkColl(dino, o)) {
            gameState = "DYING";
            dino.state = "DEAD";
            dino.frame = 0;
            sounds.die.play().catch(()=>{});
            ui.flashOp = 0.7;
        }

        if(o.x < -100) obstacles.splice(i, 1);
    }
}

function checkColl(d, o) {
    let dx = d.x + 20;
    let dy = d.y + 15;
    let dw = CONFIG.dinoSize - 40;
    let dh = CONFIG.dinoSize - 25;

    if (d.state === "DUCK") {
        dh = 35; 
        dy = d.y + 50; 
    }

    let ox = o.x + 8;
    let oy = o.y + 8;
    let ow = o.w - 16;
    let oh = o.h - 16;

    return (dx < ox + ow && dx + dw > ox && dy < oy + oh && dy + dh > oy);
}

function draw() {
    ctx.clearRect(0,0, canvas.width, canvas.height);

    if(assets.bg) ctx.drawImage(assets.bg, 0, 0, canvas.width, canvas.height);

    if(assets.ground) {
        let x = -groundOffset;
        while(x < canvas.width) {
            ctx.drawImage(assets.ground, x, canvas.height - CONFIG.groundH, assets.ground.width, CONFIG.groundH);
            x += assets.ground.width;
        }
    }

    obstacles.forEach(o => {
        if(o.type === "CACTUS") ctx.drawImage(assets.cactus, o.x, o.y, o.w, o.h);
        else {
            let img = assets.bird[o.frame % assets.bird.length];
            if(img) ctx.drawImage(img, o.x, o.y, o.w, o.h);
        }
    });

    let sprite;
    if(dino.state === "IDLE") sprite = assets.idle[Math.floor(frames/10) % assets.idle.length];
    else if(dino.state === "DEAD") sprite = (gameState === "GAMEOVER") ? assets.dead[7] : assets.dead[dino.frame % 8];
    else if(dino.state === "JUMP") sprite = assets.jump[Math.floor(frames/5) % 12];
    else if(dino.state === "DUCK") sprite = assets.dead[6] || assets.run[0]; 
    else sprite = assets.run[Math.floor(frames/4) % 8];

    if(sprite) ctx.drawImage(sprite, dino.x, dino.y, CONFIG.dinoSize, CONFIG.dinoSize);

    if(ui.flashOp > 0.01) {
        ctx.fillStyle = `rgba(255,255,255,${ui.flashOp})`;
        ctx.fillRect(0,0, canvas.width, canvas.height);
    }

    drawUI();
}

function drawUI() {
    if (gameState === "HOME") {
        ctx.fillStyle = "#fff";
        ctx.strokeStyle = "#222";
        ctx.lineWidth = 6;
        ctx.textAlign = "center";
        
        ctx.font = "80px 'Fredoka One'";
        ctx.strokeText("DINO RUN", canvas.width/2, 160);
        ctx.fillText("DINO RUN", canvas.width/2, 160);

        if (assets.btnPlay) {
            const w = 150 * ui.pulse;
            const h = 150 * ui.pulse;
            ctx.drawImage(assets.btnPlay, canvas.width/2 - w/2, 260 - h/2, w, h);
        }
    }

    if (gameState === "PLAY" || gameState === "DYING") {
        ctx.fillStyle = "#fff";
        ctx.strokeStyle = "#333";
        ctx.lineWidth = 4;
        ctx.font = "40px 'Fredoka One'";
        ctx.textAlign = "center";
        ctx.strokeText(Math.floor(score), canvas.width/2, 60);
        ctx.fillText(Math.floor(score), canvas.width/2, 60);
    }

    if (gameState === "GAMEOVER") {
        ctx.save();
        ctx.translate(0, ui.textY);
        ctx.font = "60px 'Fredoka One'";
        ctx.fillStyle = "#ff6f00";
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 5;
        ctx.textAlign = "center";
        ctx.strokeText("GAME OVER", canvas.width/2, 0);
        ctx.fillText("GAME OVER", canvas.width/2, 0);
        ctx.restore();

        ctx.save();
        ctx.translate(0, ui.boardY);
        const pW = 320, pH = 170;
        const pX = canvas.width/2 - pW/2, pY = 0;

        ctx.fillStyle = "#ffe0b2";
        ctx.strokeStyle = "#5d4037";
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.roundRect(pX, pY, pW, pH, 15);
        ctx.fill();
        ctx.stroke();

        ctx.fillStyle = "#e65100";
        ctx.font = "24px 'Fredoka One'";
        ctx.textAlign = "right";
        ctx.fillText("SCORE", pX+290, pY+45);
        ctx.fillText("BEST", pX+290, pY+105);

        ctx.fillStyle = "#333";
        ctx.font = "35px 'Fredoka One'";
        ctx.fillText(Math.floor(score), pX+290, pY+80);
        ctx.fillText(Math.floor(highScore), pX+290, pY+140);
        
        ctx.beginPath();
        ctx.arc(pX+70, pY+85, 40, 0, Math.PI*2);
        ctx.fillStyle = score > 1000 ? "#ffca28" : "#cfd8dc"; 
        ctx.fill();
        ctx.strokeStyle = "#333";
        ctx.lineWidth = 2;
        ctx.stroke();

        ctx.restore();

        if(assets.btnReplay) {
            const w = 150 * ui.pulse;
            const h = 150 * ui.pulse;
            ctx.drawImage(assets.btnReplay, canvas.width/2 - w/2, (ui.boardY + 190) - h/2, w, h);
        }
    }
}

function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
}

const checkClick = () => {
    if (gameState === "HOME") startGame();
    else if (gameState === "GAMEOVER") {
         if (Math.abs(ui.boardY - ui.targetBoardY) < 5) goHome();
    }
};

window.addEventListener('keydown', e => {
    if(e.code === 'ArrowUp' || e.code === 'Space') input.up = true;
    if(e.code === 'ArrowDown') input.down = true;
    if(gameState !== "PLAY") checkClick();
});
window.addEventListener('keyup', e => {
    if(e.code === 'ArrowDown') input.down = false;
    if(e.code === 'ArrowUp') input.up = false;
});

canvas.addEventListener('mousedown', (e) => {
    // Only check clicks on desktop if not interacting with mobile buttons
    // But since mobile buttons are 'absolute', this listener is mainly for desktop
    if(!isMobile) {
        if (gameState === "PLAY") input.up = true;
        else checkClick();
    } else {
        // On mobile, taps on canvas trigger game start/restart if needed
        if (gameState !== "PLAY") checkClick();
    }
});
canvas.addEventListener('mouseup', () => input.up = false);

init();

</script>
</body>
</html>
