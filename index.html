<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Dino Run Extreme</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap');

        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #1a1a1a;
            font-family: 'Fredoka One', cursive;
            overflow: hidden;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        #game-container {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        canvas {
            display: block;
            max-width: 100%;
            max-height: 100%;
            aspect-ratio: 16/9;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            background-color: #4AC;
            border-radius: 8px;
        }

        /* DARK LOADER */
        #loader {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: #1a1a1a;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            transition: opacity 0.4s;
        }

        h1 { margin: 0 0 20px 0; color: #f0f0f0; font-size: 5vw; letter-spacing: 2px; }
        @media (min-width: 800px) { h1 { font-size: 40px; } }

        #progress-bar {
            width: 50%;
            max-width: 400px;
            height: 15px;
            background: #333;
            border-radius: 10px;
            border: 1px solid #555;
            overflow: hidden;
        }
        #progress-fill {
            height: 100%;
            width: 0%;
            background: #ff8800;
            transition: width 0.1s linear;
        }

        /* Mobile Controls */
        #mobile-controls {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            height: 0;
            display: none; 
            z-index: 50;
        }

        .control-btn {
            position: absolute;
            bottom: 15px;
            width: 90px;
            height: 90px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 40px;
            color: white;
            pointer-events: auto;
            backdrop-filter: blur(5px);
            -webkit-tap-highlight-color: transparent;
        }

        #btn-duck { left: 30px; }
        #btn-jump { right: 30px; }

        .control-btn:active {
            background: rgba(255, 255, 255, 0.5);
            transform: scale(0.9);
        }
    </style>
</head>
<body>

<div id="game-container">
    <div id="loader">
        <h1>DINO RUN</h1>
        <div id="progress-bar"><div id="progress-fill"></div></div>
    </div>
    
    <div id="mobile-controls">
        <div id="btn-duck" class="control-btn">⬇️</div>
        <div id="btn-jump" class="control-btn">⬆️</div>
    </div>

    <canvas id="gameCanvas" width="800" height="450"></canvas>
</div>

<script>
/**
 * DINO RUN - "ADDICTIVE CHALLENGE" EDITION
 * 
 * 1. Progression:
 *    - Speed increases linearly.
 *    - Cluster Size increases based on score thresholds (1 -> 2 -> 3 -> 4 -> 5).
 * 2. Spawning: 
 *    - Logic calculates required jump distance + buffer to ensure "Fairness".
 *    - Birds never mix inside a Cactus cluster.
 * 3. Motivation: 
 *    - Best Score resets every time (Session Best).
 *    - Target Score displayed is Current + 50 (Carrot on stick).
 */

const MAIN_HOME_URL = "index.html"; 

const ASSETS_SRC = {
    bg: "https://github.com/Rajacajustin/gs_1/blob/main/dr_ge_1/dr_ge_1_as/dr_ge_1_as_bgs/dr_ge_1_as_bgs_1/bg_2.png?raw=true",
    ground: "https://github.com/Rajacajustin/gs_1/blob/main/dr_ge_1/dr_ge_1_as/dr_ge_1_as_gs/dr_ge_1_as_gs_1/gd_1.png?raw=true",
    cactus: "https://github.com/Rajacajustin/gs_1/blob/main/dr_ge_1/dr_ge_1_as/dr_ge_1_as_os/dr_ge_1_as_os_1/cs_1.png?raw=true",
    btnPlay: "https://github.com/Rajacajustin/gs_1/blob/main/as/as_ui/as_ui_1/as_ui_1_ui_bs_1/py_ne_ui_bn.png?raw=true",
    btnReplay: "https://github.com/Rajacajustin/gs_1/blob/main/as/as_ui/as_ui_1/as_ui_1_ui_bs_1/ry_ne_ui_bn.png?raw=true",
    iconBack: "https://github.com/Rajacajustin/gs_1/blob/main/as/as_ui/as_ui_1/as_ui_1_in/aw_bk_in_24dp_000000.png?raw=true",
    iconHome: "https://github.com/Rajacajustin/gs_1/blob/main/as/as_ui/as_ui_1/as_ui_1_in/he_in_24dp_000000.png?raw=true",

    idle: Array.from({length:10}, (_,i)=> `https://github.com/Rajacajustin/gs_1/blob/main/dr_ge_1/dr_ge_1_as/dr_ge_1_as_dr/dr_ge_1_as_dr_1/dr_le_${i+1}.png?raw=true`),
    run: Array.from({length:8}, (_,i)=> `https://github.com/Rajacajustin/gs_1/blob/main/dr_ge_1/dr_ge_1_as/dr_ge_1_as_dr/dr_ge_1_as_dr_1/dr_rn_${i+1}.png?raw=true`),
    jump: Array.from({length:12}, (_,i)=> `https://github.com/Rajacajustin/gs_1/blob/main/dr_ge_1/dr_ge_1_as/dr_ge_1_as_dr/dr_ge_1_as_dr_1/dr_jp_${i+1}.png?raw=true`),
    dead: Array.from({length:8}, (_,i)=> `https://github.com/Rajacajustin/gs_1/blob/main/dr_ge_1/dr_ge_1_as/dr_ge_1_as_dr/dr_ge_1_as_dr_1/dr_dd_${i+1}.png?raw=true`),
    bird: Array.from({length:4}, (_,i)=> `https://github.com/Rajacajustin/gs_1/blob/main/dr_ge_1/dr_ge_1_as/dr_ge_1_as_os/dr_ge_1_as_os_1/dr_ge_1_as_os_1_bds_1/be_bd_${i+1}.png?raw=true`),
    
    bgMusic: "https://github.com/risraelrajacir/sample_0_1/raw/refs/heads/main/8-bit-background-music-for-arcade-game-come-on-mario-164702.mp3",
    sndJump: "https://github.com/Rajacajustin/gs_1/raw/refs/heads/main/dr_ge_1/dr_ge_1_as/dr_ge_1_as_sd_es/dr_ge_1_as_sd_es_1/jp_sd_et.mp3",
    sndDuck: "https://github.com/Rajacajustin/gs_1/raw/refs/heads/main/dr_ge_1/dr_ge_1_as/dr_ge_1_as_sd_es/dr_ge_1_as_sd_es_1/wh_sd_et.mp3",
    sndDie: "https://github.com/Rajacajustin/gs_1/raw/refs/heads/main/se_ge_1/se_ge_1_as/se_ge_1_as_sd_es/se_ge_1_as_sd_es_1/ge_or_sd_et_.mp3",
    sndClick: "https://github.com/Rajacajustin/gs_1/raw/refs/heads/main/as/as_sd_es/as_sd_es_1/ck_sd_et.mp3"
};

const CONFIG = {
    startSpeed: 8.5,     
    maxSpeed: 24.0,      
    gravity: 0.75,
    jumpForce: -14.5,
    groundH: 80,
    dinoSize: 85,
    duckDuration: 45
};

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const loader = document.getElementById('loader');
const progress = document.getElementById('progress-fill');

let assets = {};
let sounds = {};
let gameState = "INIT"; 
let score = 0;
// Best Score resets every time (Session Motivation)
let sessionBest = 0; 
let speed = CONFIG.startSpeed;
let frames = 0;

let dino = { x: 50, y: 0, vy: 0, state: "IDLE", frame: 0 };
let obstacles = [];
let groundOffset = 0;
let input = { up: false, down: false };
let duckTimer = 0;
let inputLockDuck = false;
let activeBtn = null; 

let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
let ui = { flashOp: 0, textY: -100, boardY: 600, targetBoardY: 150, pulse: 1 };

// SETUP MOBILE CONTROLS
if(isMobile) {
    document.getElementById('mobile-controls').style.display = 'block';
    const btnJump = document.getElementById('btn-jump');
    const btnDuck = document.getElementById('btn-duck');

    btnJump.addEventListener('touchstart', (e) => {
        e.preventDefault(); e.stopPropagation();
        if (gameState === "PLAY") input.up = true;
        else if (gameState === "GAMEOVER" || gameState === "HOME") handleInteraction(e);
    }, {passive: false});

    btnJump.addEventListener('touchend', (e) => { e.preventDefault(); input.up = false; });

    btnDuck.addEventListener('touchstart', (e) => {
        e.preventDefault(); e.stopPropagation();
        if (gameState === "PLAY") input.down = true;
    }, {passive: false});

    btnDuck.addEventListener('touchend', (e) => { e.preventDefault(); input.down = false; });
}

// --- ASSET LOADER ---
async function init() {
    let toLoad = [];
    const add = (k, s) => toLoad.push({k, s});
    add('bg', ASSETS_SRC.bg); add('ground', ASSETS_SRC.ground);
    add('cactus', ASSETS_SRC.cactus); add('btnPlay', ASSETS_SRC.btnPlay);
    add('btnReplay', ASSETS_SRC.btnReplay);
    add('iconBack', ASSETS_SRC.iconBack);
    add('iconHome', ASSETS_SRC.iconHome);
    
    ASSETS_SRC.idle.forEach((s, i)=> add(`idle_${i}`, s));
    ASSETS_SRC.run.forEach((s, i)=> add(`run_${i}`, s));
    ASSETS_SRC.jump.forEach((s, i)=> add(`jump_${i}`, s));
    ASSETS_SRC.dead.forEach((s, i)=> add(`dead_${i}`, s));
    ASSETS_SRC.bird.forEach((s, i)=> add(`bird_${i}`, s));

    let loaded = 0;
    const promise = (item) => new Promise(res => {
        const img = new Image();
        img.src = item.s;
        img.onload = () => {
            loaded++;
            progress.style.width = (loaded/toLoad.length * 100) + "%";
            res({k:item.k, img});
        };
        img.onerror = () => res({k:item.k, img:null});
    });

    const results = await Promise.all(toLoad.map(promise));
    
    assets.idle=[]; assets.run=[]; assets.jump=[]; assets.dead=[]; assets.bird=[];
    results.forEach(({k, img}) => {
        if(k.includes('_')) {
            const [type, idx] = k.split('_');
            assets[type][parseInt(idx)] = img;
        } else {
            assets[k] = img;
        }
    });

    sounds.bgm = new Audio(ASSETS_SRC.bgMusic);
    sounds.bgm.loop = true;
    sounds.bgm.volume = 0.5;

    sounds.jump = new Audio(ASSETS_SRC.sndJump);
    sounds.duck = new Audio(ASSETS_SRC.sndDuck);
    sounds.die = new Audio(ASSETS_SRC.sndDie);
    sounds.click = new Audio(ASSETS_SRC.sndClick);

    setTimeout(() => {
        loader.style.opacity = 0;
        setTimeout(() => loader.remove(), 500);
        goHome();
        loop();
    }, 500);
}

function playClickSound() {
    sounds.click.currentTime = 0;
    sounds.click.play().catch(()=>{});
}

function goHome() {
    gameState = "HOME";
    resetGame();
    sounds.bgm.pause();
    sounds.bgm.currentTime = 0;
    ui.flashOp = 0; ui.textY = -100; ui.boardY = canvas.height + 200;
}

function startGame() {
    gameState = "PLAY";
    resetGame();
    sounds.bgm.currentTime = 0;
    sounds.bgm.play().catch(()=>{});
}

function resetGame() {
    dino.y = canvas.height - CONFIG.groundH - CONFIG.dinoSize + 10; 
    dino.vy = 0;
    dino.state = "RUN"; 
    obstacles = [];
    score = 0;
    speed = CONFIG.startSpeed;
    frames = 0;
    groundOffset = 0;
    duckTimer = 0;
    inputLockDuck = false;
    activeBtn = null;
    
    // Reset session best on restart if desired, or keep per session.
    // User asked "best should reset every time" (meaning per run? or per reload?)
    // Usually "Best" means best of session. "Score" resets to 0. 
    // I will keep sessionBest tracking current session max.
}

function update() {
    // Pulse: Front/Back Sine Wave
    ui.pulse = 1 + Math.sin(frames * 0.15) * 0.08; 

    if (gameState === "HOME") {
        frames++;
        dino.state = "IDLE";
    } 
    else if (gameState === "PLAY") {
        frames++;
        score++;
        
        // Speed Progression
        if (speed < CONFIG.maxSpeed) {
            speed += 0.0025; 
        }
        
        groundOffset = (groundOffset + speed) % assets.ground.width;
        
        const groundTop = canvas.height - CONFIG.groundH;
        const floor = groundTop - CONFIG.dinoSize + 10;

        dino.y += dino.vy;

        if (dino.y >= floor) {
            dino.y = floor;
            dino.vy = 0;

            if (duckTimer > 0) {
                dino.state = "DUCK";
                duckTimer--;
                if(duckTimer <= 0) dino.state = "RUN"; 
            } else {
                dino.state = "RUN";
            }

            if (input.up) {
                dino.vy = CONFIG.jumpForce;
                dino.state = "JUMP";
                duckTimer = 0;
                sounds.jump.currentTime = 0;
                sounds.jump.play().catch(()=>{});
                input.up = false;
            } 
            else if (input.down) {
                if (!inputLockDuck && duckTimer <= 0) {
                    duckTimer = CONFIG.duckDuration;
                    dino.state = "DUCK";
                    sounds.duck.currentTime = 0;
                    sounds.duck.play().catch(()=>{});
                    inputLockDuck = true;
                }
            } else {
                inputLockDuck = false;
            }

        } else {
            dino.vy += CONFIG.gravity;
            dino.state = "JUMP";
            if(input.down) dino.vy += 1.5;
        }

        manageObstacles();
    }
    else if (gameState === "DYING") {
        frames++;
        sounds.bgm.pause();
        const floor = canvas.height - CONFIG.groundH - CONFIG.dinoSize + 10;
        
        if (dino.y < floor) dino.y += CONFIG.gravity * 2;
        else dino.y = floor;

        if (dino.frame < assets.dead.length - 1) {
            if (frames % 4 === 0) dino.frame++;
        } else {
            gameState = "GAMEOVER";
            // Check Session Best
            if(score > sessionBest) sessionBest = score;
        }
    }
    else if (gameState === "GAMEOVER") {
        frames++; // For pulse
        const floor = canvas.height - CONFIG.groundH - CONFIG.dinoSize + 10;
        if (dino.y < floor) dino.y += CONFIG.gravity * 2;

        if(ui.flashOp > 0) ui.flashOp -= 0.03;
        if(ui.textY < 80) ui.textY += (80 - ui.textY) * 0.1;
        if(ui.boardY > ui.targetBoardY) ui.boardY += (ui.targetBoardY - ui.boardY) * 0.1;
    }
}

function manageObstacles() {
    // Distance formula for safety: Speed * JumpFrames + Buffer
    let safeGap = (45 * speed) + 150;
    
    if (obstacles.length === 0 || canvas.width - obstacles[obstacles.length-1].x > safeGap) {
        if(Math.random() > 0.1) {
            
            let type = Math.random() > 0.6 ? "BIRD" : "CACTUS";
            
            // --- DIFFICULTY TIER LOGIC ---
            let maxCluster = 1;
            if (score > 500) maxCluster = 2;
            if (score > 1000) maxCluster = 3;
            if (score > 2000) maxCluster = 5;
            if (score > 4000) maxCluster = 8; // Extreme wall
            if (score > 6000) maxCluster = 10; // Impossible wall (needs perfect jump)

            let count = 1;
            if (type === "CACTUS") {
                // Skew random towards higher difficulty as maxCluster increases
                count = Math.floor(Math.random() * maxCluster) + 1;
                // Force higher clusters occasionally
                if (score > 3000 && Math.random() > 0.7) count = maxCluster; 
            }

            const groundTop = canvas.height - CONFIG.groundH;
            
            let currentX = canvas.width;

            for(let i=0; i<count; i++) {
                let obs = { type, x: currentX, w:0, h:0, frame:0 };
                
                if (type === "CACTUS") {
                    obs.w = 50; obs.h = 60;
                    obs.y = groundTop - obs.h; // Top of ground
                } else {
                    // Bird Logic
                    obs.w = 50; obs.h = 40;
                    let isHigh = Math.random() > 0.5;
                    if (isHigh) obs.y = groundTop - 85; 
                    else obs.y = groundTop - 50; 
                }
                obstacles.push(obs);

                // **CLUSTER SPACING**
                // Pack them tight (40px) to form a "Wall".
                // But every 3rd cactus, add a tiny gap or break? 
                // Request said "in one place". So we pack them tight.
                // 10 cacti x 40px = 400px wide. At speed 15, that's 26 frames to clear.
                // Jump duration is 45 frames. It IS jumpable.
                currentX += 45; 
            }
        }
    }

    for (let i = obstacles.length - 1; i >= 0; i--) {
        let o = obstacles[i];
        o.x -= speed;
        if(o.type === "BIRD" && frames % 10 === 0) o.frame++;

        if (checkColl(dino, o)) {
            gameState = "DYING";
            dino.state = "DEAD";
            dino.frame = 0;
            sounds.die.play().catch(()=>{});
            ui.flashOp = 0.7;
        }

        if(o.x < -100) obstacles.splice(i, 1);
    }
}

function checkColl(d, o) {
    let dx = d.x + 20;
    let dy = d.y + 15;
    let dw = CONFIG.dinoSize - 40;
    let dh = CONFIG.dinoSize - 25;

    if (d.state === "DUCK") {
        dh = 35; 
        dy = d.y + 50; 
    }

    let ox = o.x + 8;
    let oy = o.y + 8;
    let ow = o.w - 16;
    let oh = o.h - 16;

    return (dx < ox + ow && dx + dw > ox && dy < oy + oh && dy + dh > oy);
}

function draw() {
    ctx.clearRect(0,0, canvas.width, canvas.height);

    if(assets.bg) ctx.drawImage(assets.bg, 0, 0, canvas.width, canvas.height);

    if(assets.ground) {
        let x = -groundOffset;
        while(x < canvas.width) {
            ctx.drawImage(assets.ground, x, canvas.height - CONFIG.groundH, assets.ground.width, CONFIG.groundH);
            x += assets.ground.width;
        }
    }

    obstacles.forEach(o => {
        if(o.type === "CACTUS") ctx.drawImage(assets.cactus, o.x, o.y, o.w, o.h);
        else {
            let img = assets.bird[o.frame % assets.bird.length];
            if(img) ctx.drawImage(img, o.x, o.y, o.w, o.h);
        }
    });

    let sprite;
    if(dino.state === "IDLE") sprite = assets.idle[Math.floor(frames/10) % assets.idle.length];
    else if(dino.state === "DEAD") sprite = (gameState === "GAMEOVER") ? assets.dead[7] : assets.dead[dino.frame % 8];
    else if(dino.state === "JUMP") sprite = assets.jump[Math.floor(frames/5) % 12];
    else if(dino.state === "DUCK") sprite = assets.dead[6] || assets.run[0]; 
    else sprite = assets.run[Math.floor(frames/4) % 8];

    if(sprite) ctx.drawImage(sprite, dino.x, dino.y, CONFIG.dinoSize, CONFIG.dinoSize);

    if(ui.flashOp > 0.01) {
        ctx.fillStyle = `rgba(255,255,255,${ui.flashOp})`;
        ctx.fillRect(0,0, canvas.width, canvas.height);
    }

    drawUI();
}

function drawUI() {
    if (gameState === "HOME") {
        ctx.fillStyle = "#fff";
        ctx.strokeStyle = "#222";
        ctx.lineWidth = 6;
        ctx.textAlign = "center";
        
        ctx.font = "80px 'Fredoka One'";
        ctx.strokeText("DINO RUN", canvas.width/2, 160);
        ctx.fillText("DINO RUN", canvas.width/2, 160);

        if (assets.btnPlay) {
            const scale = (activeBtn === 'play') ? 0.9 : ui.pulse;
            const w = 150 * scale;
            const h = 150 * scale;
            ctx.drawImage(assets.btnPlay, canvas.width/2 - w/2, 260 - h/2, w, h);
        }

        const scale = (activeBtn === 'back') ? 0.9 : 1.0;
        ctx.fillStyle = "rgba(255,255,255,0.9)";
        ctx.beginPath();
        ctx.roundRect(20, 20, 220 * scale, 50 * scale, 25);
        ctx.fill();
        if(assets.iconBack) ctx.drawImage(assets.iconBack, 30, 30, 30 * scale, 30 * scale);
        ctx.fillStyle = "#333";
        ctx.textAlign = "left";
        ctx.font = (20 * scale) + "px 'Fredoka One'";
        ctx.fillText("Back to Games", 70, 52);
    }

    if (gameState === "PLAY" || gameState === "DYING") {
        ctx.fillStyle = "#fff";
        ctx.strokeStyle = "#333";
        ctx.lineWidth = 4;
        ctx.font = "40px 'Fredoka One'";
        ctx.textAlign = "center";
        ctx.strokeText(Math.floor(score), canvas.width/2, 60);
        ctx.fillText(Math.floor(score), canvas.width/2, 60);
    }

    if (gameState === "GAMEOVER") {
        ctx.save();
        ctx.translate(0, ui.textY);
        ctx.font = "60px 'Fredoka One'";
        ctx.fillStyle = "#ff6f00";
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 5;
        ctx.textAlign = "center";
        ctx.strokeText("GAME OVER", canvas.width/2, 0);
        ctx.fillText("GAME OVER", canvas.width/2, 0);
        ctx.restore();

        ctx.save();
        ctx.translate(0, ui.boardY);
        const pW = 320, pH = 170;
        const pX = canvas.width/2 - pW/2, pY = 0;

        ctx.fillStyle = "#ffe0b2";
        ctx.strokeStyle = "#5d4037";
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.roundRect(pX, pY, pW, pH, 15);
        ctx.fill();
        ctx.stroke();

        ctx.fillStyle = "#e65100";
        ctx.font = "24px 'Fredoka One'";
        ctx.textAlign = "right";
        ctx.fillText("SCORE", pX+290, pY+45);
        ctx.fillText("BEST", pX+290, pY+105);

        ctx.fillStyle = "#333";
        ctx.font = "35px 'Fredoka One'";
        
        // --- MOTIVATIONAL SCORE LOGIC ---
        // Best = Current + 50 (Unless current IS best)
        let displayScore = Math.floor(score);
        let motivationalBest = (score > sessionBest) ? score : (sessionBest > 0 ? sessionBest : 50) + 50; 
        // Logic tweak: If you beat session best, motivational target bumps up again
        if (score >= sessionBest && score > 0) motivationalBest = score + 50;

        ctx.fillText(displayScore, pX+290, pY+80);
        ctx.fillText(Math.floor(motivationalBest), pX+290, pY+140);
        
        ctx.beginPath();
        ctx.arc(pX+70, pY+85, 40, 0, Math.PI*2);
        ctx.fillStyle = score > 1500 ? "#ffca28" : (score > 500 ? "#cfd8dc" : "#a1887f"); 
        ctx.fill();
        ctx.strokeStyle = "#333";
        ctx.lineWidth = 2;
        ctx.stroke();

        ctx.restore();

        if(assets.btnReplay) {
            // ANIMATED REPLAY (PULSE)
            const scale = (activeBtn === 'replay') ? 0.9 : ui.pulse;
            const w = 150 * scale;
            const h = 150 * scale;
            ctx.drawImage(assets.btnReplay, canvas.width/2 - w/2, (ui.boardY + 230) - h/2, w, h);
        }

        const scale = (activeBtn === 'home') ? 0.9 : 1.0;
        const hSize = 50 * scale;
        const hX = canvas.width - 20 - 50 + (50-hSize)/2; 
        const hY = 20 + (50-hSize)/2;
        
        ctx.fillStyle = "rgba(255,255,255,0.9)";
        ctx.beginPath();
        ctx.roundRect(hX, hY, hSize, hSize, 25);
        ctx.fill();
        if(assets.iconHome) ctx.drawImage(assets.iconHome, hX + 10, hY + 10, 30 * scale, 30 * scale);
    }
}

function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
}

// Global Interaction Handler
function handleInteraction(e) {
    let clientX, clientY;
    if(e.touches) {
        clientX = e.touches[0].clientX;
        clientY = e.touches[0].clientY;
    } else {
        clientX = e.clientX;
        clientY = e.clientY;
    }

    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    
    const x = (clientX - rect.left) * scaleX;
    const y = (clientY - rect.top) * scaleY;

    if (gameState === "HOME") {
        if (x > canvas.width/2 - 75 && x < canvas.width/2 + 75 && y > 260 - 75 && y < 260 + 75) {
            activeBtn = 'play';
            playClickSound();
        }
        if (x >= 20 && x <= 240 && y >= 20 && y <= 70) {
            activeBtn = 'back';
            playClickSound();
        }
    }
    else if (gameState === "GAMEOVER") {
        // Replay
        if (x > canvas.width/2 - 75 && x < canvas.width/2 + 75 && y > (ui.boardY + 230) - 75 && y < (ui.boardY + 230) + 75) {
            activeBtn = 'replay';
            playClickSound();
        }
        // Home
        if (x >= canvas.width - 70 && x <= canvas.width - 20 && y >= 20 && y <= 70) {
            activeBtn = 'home';
            playClickSound();
        }
    }
}

function handleRelease() {
    if (activeBtn === 'play') startGame();
    if (activeBtn === 'back') setTimeout(() => window.location.href = MAIN_HOME_URL, 100);
    if (activeBtn === 'replay') goHome();
    if (activeBtn === 'home') setTimeout(() => window.location.href = MAIN_HOME_URL, 100);
    activeBtn = null;
}

// Event Listeners
window.addEventListener('keydown', e => {
    if(e.code === 'ArrowUp' || e.code === 'Space') input.up = true;
    if(e.code === 'ArrowDown') input.down = true;
});
window.addEventListener('keyup', e => {
    if(e.code === 'ArrowDown') input.down = false;
    if(e.code === 'ArrowUp') input.up = false;
});

canvas.addEventListener('mousedown', e => {
    if (gameState === "PLAY") input.up = true;
    else handleInteraction(e);
});

canvas.addEventListener('mouseup', e => {
    if (gameState === "PLAY") input.up = false;
    else handleRelease();
});

canvas.addEventListener('touchstart', e => {
    if(e.target.id === 'gameCanvas') e.preventDefault();
    if (gameState === "PLAY") {
        // Fallback if mobile buttons not used
        const rect = canvas.getBoundingClientRect();
        const x = (e.touches[0].clientX - rect.left) * (canvas.width / rect.width);
        if (x < canvas.width/2) input.down = true; else input.up = true;
    } else {
        handleInteraction(e);
    }
}, {passive:false});

canvas.addEventListener('touchend', e => {
    if(e.target.id === 'gameCanvas') e.preventDefault();
    if (gameState === "PLAY") { input.up=false; input.down=false; }
    else handleRelease();
});

init();

</script>
</body>
</html>
