<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Flappy Bird</title>
    <style>
        html, body {
            margin: 0; padding: 0; overflow: hidden;
            width: 100%; height: 100%; background-color: #333;
        }
        #game-container {
            width: 100%; height: 100%; display: flex;
            justify-content: center; align-items: center;
        }
        #game-wrapper {
            position: relative; /* This is the new key for positioning the loader */
            border: 2px solid #000;
            overflow: hidden; /* Ensures nothing spills out */
        }
        canvas {
            display: block; /* Removes any potential ghost margins */
            background-color: #70c5ce; cursor: pointer;
            touch-action: none; -webkit-tap-highlight-color: transparent;
            user-select: none; -webkit-user-select: none;
        }
        #loader-container {
            position: absolute; /* Changed from fixed to absolute */
            top: 0; left: 0; width: 100%; height: 100%;
            display: flex; justify-content: center; align-items: center;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 100; transition: opacity 0.5s ease-out;
        }
        #loader-content {
            text-align: center; color: white; font-family: 'Arial Black', sans-serif;
        }
        #progress-bar-container {
            width: 250px; height: 20px; background-color: #555;
            border: 2px solid #fff; border-radius: 10px; margin-top: 10px;
        }
        #progress-bar {
            width: 0%; height: 100%; background-color: #f7e43b;
            border-radius: 8px; transition: width 0.1s linear;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="game-wrapper">
            <div id="loader-container">
                <div id="loader-content">
                    <p>Loading Game...</p>
                    <div id="progress-bar-container">
                        <div id="progress-bar"></div>
                    </div>
                </div>
            </div>
            <canvas id="gameCanvas" width="288" height="512"></canvas>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('game-container');
        const gameWrapper = document.getElementById('game-wrapper');
        const loaderContainer = document.getElementById('loader-container');
        const progressBar = document.getElementById('progress-bar');

        function resizeGame() {
            const gameRatio = canvas.width / canvas.height;
            const containerRatio = gameContainer.clientWidth / gameContainer.clientHeight;
            let newWidth, newHeight;

            if (containerRatio < gameRatio) {
                newWidth = gameContainer.clientWidth;
                newHeight = newWidth / gameRatio;
            } else {
                newHeight = gameContainer.clientHeight;
                newWidth = newHeight * gameRatio;
            }
            
            // Apply size to the wrapper, and the canvas/loader will fill it
            gameWrapper.style.width = newWidth + 'px';
            gameWrapper.style.height = newHeight + 'px';
            canvas.style.width = '100%';
            canvas.style.height = '100%';
        }
        window.addEventListener('resize', resizeGame);
        window.addEventListener('orientationchange', resizeGame);
        resizeGame();

        const assets = {
            bird: [
                "https://github.com/Rajacajustin/gs_1/blob/main/bd_ge_1/bd_ge_1_as/bd_ge_1_as_bs/bd_ge_1_as_bs_1/be_bd_1.png?raw=true",
                "https://github.com/Rajacajustin/gs_1/blob/main/bd_ge_1/bd_ge_1_as/bd_ge_1_as_bs/bd_ge_1_as_bs_1/be_bd_2.png?raw=true",
                "https://github.com/Rajacajustin/gs_1/blob/main/bd_ge_1/bd_ge_1_as/bd_ge_1_as_bs/bd_ge_1_as_bs_1/be_bd_3.png?raw=true",
                "https://github.com/Rajacajustin/gs_1/blob/main/bd_ge_1/bd_ge_1_as/bd_ge_1_as_bs/bd_ge_1_as_bs_1/be_bd_4.png?raw=true"
            ],
            background: "https://github.com/Rajacajustin/gs_1/blob/main/bd_ge_1/bd_ge_1_as/bd_ge_1_as_bgs/bd_ge_1_as_bgs_1/bg_dy_1.png?raw=true",
            base: "https://github.com/Rajacajustin/gs_1/blob/main/bd_ge_1/bd_ge_1_as/bd_ge_1_as_bes/bd_ge_1_as_bes_1/gd_1.png?raw=true",
            pipeTop: "https://github.com/Rajacajustin/gs_1/blob/main/bd_ge_1/bd_ge_1_as/bd_ge_1_as_ps/bd_ge_1_as_ps_1/gn_pe_tp.png?raw=true",
            pipeBottom: "https://github.com/Rajacajustin/gs_1/blob/main/bd_ge_1/bd_ge_1_as/bd_ge_1_as_ps/bd_ge_1_as_ps_1/gn_pe_bm.png?raw=true",
            uiBackground: "https://github.com/Rajacajustin/gs_1/blob/main/as/as_ui/as_ui_1/UIbg.png?raw=true",
            getReady: "https://github.com/Rajacajustin/gs_1/blob/main/as/as_ui/as_ui_1/tt_Gt_Ry_ui.png?raw=true",
            gameOver: "https://github.com/Rajacajustin/gs_1/blob/main/as/as_ui/as_ui_1/tt_Ge_Or_ui.png?raw=true",
            playButton: "https://github.com/Rajacajustin/gs_1/blob/main/as/as_ui/as_ui_1/as_ui_1_ui_bs_1/py_ne_ui_bn.png?raw=true",
            replayButton: "https://github.com/Rajacajustin/gs_1/blob/main/as/as_ui/as_ui_1/as_ui_1_ui_bs_1/ry_ne_ui_bn.png?raw=true",
            tapSymbol: "https://github.com/Rajacajustin/gs_1/blob/main/as/as_ui/as_ui_1/tp_sl_ui.png?raw=true",
            tapTickSymbol: "https://github.com/Rajacajustin/gs_1/blob/main/as/as_ui/as_ui_1/tp_Tk_ui.png?raw=true",
            homeIcon: "https://github.com/Rajacajustin/gs_1/blob/main/as/as_ui/as_ui_1/as_ui_1_in/he_in_24dp_FFFFFF.png?raw=true",
            backIcon: "https://github.com/Rajacajustin/gs_1/blob/main/as/as_ui/as_ui_1/as_ui_1_in/aw_bk_in_24dp_FFFFFF.png?raw=true",
            swoosh: "https://github.com/Rajacajustin/gs_1/raw/refs/heads/main/bd_ge_1/bd_ge_1_as/bd_ge_1_as_sd_es/bd_ge_1_as_sd_es_1/sh_sd_et.mp3",
            flap: "https://github.com/Rajacajustin/gs_1/raw/refs/heads/main/bd_ge_1/bd_ge_1_as/bd_ge_1_as_sd_es/bd_ge_1_as_sd_es_1/fp_sd_et.mp3",
            point: "https://github.com/Rajacajustin/gs_1/raw/refs/heads/main/bd_ge_1/bd_ge_1_as/bd_ge_1_as_sd_es/bd_ge_1_as_sd_es_1/pt_sd_et.mp3",
            hit: "https://github.com/Rajacajustin/gs_1/raw/refs/heads/main/bd_ge_1/bd_ge_1_as/bd_ge_1_as_sd_es/bd_ge_1_as_sd_es_1/ht_sd_et.mp3",
            die: "https://github.com/Rajacajustin/gs_1/raw/refs/heads/main/bd_ge_1/bd_ge_1_as/bd_ge_1_as_sd_es/bd_ge_1_as_sd_es_1/de_sd_et.mp3",
            click: "https://github.com/Rajacajustin/gs_1/raw/refs/heads/main/as/as_sd_es/as_sd_es_1/ck_sd_et.mp3"
        };

        const images = {};
        const sounds = {};
        let totalAssets = 0;
        let assetsLoaded = 0;

        function updateLoader() {
            assetsLoaded++;
            const progress = (assetsLoaded / totalAssets) * 100;
            progressBar.style.width = progress + '%';
            if (assetsLoaded === totalAssets) {
                main(); 
                setTimeout(() => {
                    loaderContainer.style.opacity = '0';
                    setTimeout(() => { loaderContainer.style.display = 'none'; }, 500);
                }, 200);
            }
        }

        function loadAssets() {
            const imageKeys = ['background', 'base', 'pipeTop', 'pipeBottom', 'uiBackground', 'getReady', 'gameOver', 'playButton', 'replayButton', 'tapSymbol', 'tapTickSymbol', 'homeIcon', 'backIcon'];
            const soundKeys = ['swoosh', 'flap', 'point', 'hit', 'die', 'click'];
            totalAssets = imageKeys.length + assets.bird.length + soundKeys.length;
            imageKeys.forEach(key => { images[key] = new Image(); images[key].src = assets[key]; images[key].onload = updateLoader; });
            images.bird = assets.bird.map(src => { const img = new Image(); img.src = src; img.onload = updateLoader; return img; });
            soundKeys.forEach(key => { sounds[key] = new Audio(assets[key]); sounds[key].addEventListener('canplaythrough', updateLoader, { once: true }); });
        }
        
        function playSound(soundKey) {
            const sound = sounds[soundKey];
            if (sound) { sound.currentTime = 0; sound.play().catch(e => {}); }
        }
        
        function main() {
            const MAIN_HOME_URL = "index.html"; 
            let frames = 0;
            const DEGREE = Math.PI / 180;
            const state = { current: 0, getReady: 0, instructions: 1, game: 2, over: 3 };

            const flash = {
                alpha: 0, speed: 0.1,
                start: function() { this.alpha = 0.7; },
                update: function() { this.alpha = Math.max(0, this.alpha - this.speed); },
                draw: function() {
                    if (this.alpha > 0) {
                        ctx.fillStyle = `rgba(255, 255, 255, ${this.alpha})`;
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                    }
                },
                reset: function() { this.alpha = 0; }
            };

            const transition = {
                alpha: 0, speed: 0.05, active: false, targetState: -1,
                start: function(target) {
                    if (this.active) return;
                    this.active = true; this.isFadingOut = true; this.targetState = target; playSound('swoosh');
                },
                update: function() {
                    if (!this.active) return;
                    if (this.isFadingOut) {
                        this.alpha = Math.min(1, this.alpha + this.speed);
                        if (this.alpha >= 1) {
                            this.isFadingOut = false; this.isFadingIn = true;
                            if (state.current === state.over) resetGame();
                            state.current = this.targetState;
                        }
                    } else if (this.isFadingIn) {
                        this.alpha = Math.max(0, this.alpha - this.speed);
                        if (this.alpha <= 0) { this.isFadingIn = false; this.active = false; }
                    }
                },
                draw: function() {
                    if (this.alpha > 0) {
                        ctx.fillStyle = `rgba(0, 0, 0, ${this.alpha})`;
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                    }
                }
            };

            const bg = { draw: () => ctx.drawImage(images.background, 0, 0, canvas.width, canvas.height) };
            const base = {
                x: 0, y: canvas.height - 112, w: 336, h: 112, dx: 2,
                draw: function() {
                    ctx.drawImage(images.base, this.x, this.y, this.w, this.h);
                    ctx.drawImage(images.base, this.x + this.w, this.y, this.w, this.h);
                },
                update: function() {
                    if (state.current !== state.over) {
                        this.x -= this.dx;
                        if (this.x <= -this.w) this.x = 0;
                    }
                }
            };

            const bird = {
                x: 80, y: 190, w: 34, h: 24, frame: 0,
                gravity: 0.20, jump: 4.2, speed: 0, rotation: 0,
                draw: function() {
                    let birdImg = images.bird[this.frame];
                    ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.rotation);
                    ctx.drawImage(birdImg, -this.w / 2, -this.h / 2, this.w, this.h);
                    ctx.restore();
                },
                flap: function() { this.speed = -this.jump; },
                update: function() {
                    if (state.current < state.game) {
                        this.frame = Math.floor((frames / 5) % images.bird.length);
                        this.y = 190 + Math.sin(frames * DEGREE * 5) * 8;
                        this.rotation = 0;
                    } else {
                        if (state.current !== state.over || this.y < base.y - this.h/2) {
                            this.speed += this.gravity;
                            this.y += this.speed;
                        }
                        if (this.y + this.h / 2 >= base.y) {
                            this.y = base.y - this.h / 2;
                            if (state.current === state.game) {
                                state.current = state.over; playSound('hit'); flash.start(); gameOverSequence.start();
                            }
                        }
                        if (state.current === state.over) {
                            this.frame = 1;
                            if (this.y < base.y - this.h/2) this.rotation = Math.min(90 * DEGREE, this.rotation + 4 * DEGREE);
                        } else {
                            this.frame = Math.floor((frames / 5) % images.bird.length);
                            this.rotation = this.speed >= 0 ? Math.min(90 * DEGREE, this.rotation + 4 * DEGREE) : -25 * DEGREE;
                        }
                    }
                },
                reset: function() { this.speed = 0; this.y = 190; }
            };

            const pipes = {
                position: [], w: 52, h: 320, gap: 100, maxYPos: -40, dx: 2,
                draw: function() { for (let p of this.position) { ctx.drawImage(images.pipeTop, p.x, p.y); ctx.drawImage(images.pipeBottom, p.x, p.y + this.h + this.gap); }},
                update: function() {
                    if (state.current !== state.game) return;
                    if (frames % 100 === 0) this.position.push({ x: canvas.width, y: this.maxYPos - (Math.random() * 200), passed: false });
                    for (let i = this.position.length - 1; i >= 0; i--) {
                        let p = this.position[i];
                        p.x -= this.dx;
                        let b = { left: bird.x - bird.w/2, right: bird.x + bird.w/2, top: bird.y - bird.h/2, bottom: bird.y + bird.h/2 };
                        if (b.right > p.x && b.left < p.x + this.w && (b.top < p.y + this.h || b.bottom > p.y + this.h + this.gap)) {
                            state.current = state.over; playSound('hit'); playSound('die'); flash.start(); gameOverSequence.start();
                            bird.speed = 0;
                        }
                        if (p.x + this.w < bird.x && !p.passed) { score.value++; playSound('point'); p.passed = true; }
                        if (p.x + this.w < 0) this.position.splice(i, 1);
                    }
                },
                reset: function() { this.position = []; }
            };
            
            const ui = {
                titleSize: { w: 225, h: 45 }, panelSize: { w: 225, h: 112 },
                buttonSize: { w: 150, h: 150 }, tapSymbolSize: { w: 80, h: 70 },
                iconSize: { w: 24, h: 24},
                tapSymbolAlpha: 1.0, isFadingTapSymbol: false,
                isBackPressed: false, isHomePressed: false, isPlayPressed: false, isReplayPressed: false,
                get playRect() { return { x: (canvas.width - this.buttonSize.w) / 2, y: 280, ...this.buttonSize }; },
                get replayRect() { return { x: (canvas.width - this.buttonSize.w) / 2, y: 310, ...this.buttonSize }; },
                get backRect() { return { x: 10, y: 10, w: 160, h: 30 }; },
                get homeRect() { return { x: canvas.width - this.iconSize.w - 10, y: 10, ...this.iconSize }; },

                draw: function() {
                    if (state.current === state.getReady) {
                        this.drawPulsingButton(images.playButton, this.playRect, frames, this.isPlayPressed);
                        ctx.drawImage(images.getReady, (canvas.width - this.titleSize.w) / 2, 100, this.titleSize.w, this.titleSize.h);
                        this.drawBackButton();
                    } else if (state.current === state.instructions || this.isFadingTapSymbol) {
                        this.drawTapAnimation();
                    } else if (state.current === state.over) {
                        gameOverSequence.draw();
                    }
                },
                drawBackButton: function() {
                    const scale = this.isBackPressed ? 0.9 : 1.0;
                    ctx.save(); ctx.translate(this.backRect.x, this.backRect.y + this.backRect.h / 2);
                    ctx.scale(scale, scale);
                    ctx.drawImage(images.backIcon, 0, -this.iconSize.h / 2, this.iconSize.w, this.iconSize.h);
                    drawTextWithShadow("Back to Games", this.iconSize.w + 5, 5, "16px 'Arial Black', sans-serif", "left");
                    ctx.restore();
                },
                drawPulsingButton: function(image, rect, frameCount, isPressed) {
                    const scale = isPressed ? 0.9 : Math.sin(frameCount * DEGREE * 5) * 0.05 + 1;
                    ctx.save(); ctx.translate(rect.x + rect.w / 2, rect.y + rect.h / 2);
                    ctx.scale(scale, scale); ctx.drawImage(image, -rect.w / 2, -rect.h / 2, rect.w, rect.h); ctx.restore();
                },
                drawTapAnimation: function() {
                    ctx.save(); ctx.globalAlpha = this.tapSymbolAlpha;
                    let isTicked = Math.floor(frames / 20) % 2 === 0;
                    let currentSymbol = isTicked ? images.tapTickSymbol : images.tapSymbol;
                    let pulse = Math.sin(frames * DEGREE * 8) * 0.05 + 1;
                    let w = this.tapSymbolSize.w * pulse, h = this.tapSymbolSize.h * pulse;
                    ctx.drawImage(currentSymbol, (canvas.width - w) / 2, 250, w, h); ctx.restore();
                },
                drawHomeIcon: function() {
                    const scale = this.isHomePressed ? 0.9 : 1.0;
                    const r = this.homeRect;
                    ctx.save(); ctx.translate(r.x + r.w / 2, r.y + r.h / 2);
                    ctx.scale(scale, scale); ctx.drawImage(images.homeIcon, -r.w / 2, -r.h / 2, r.w, r.h); ctx.restore();
                },
                update: function() {
                    if (this.isFadingTapSymbol) {
                        this.tapSymbolAlpha -= 0.05;
                        if (this.tapSymbolAlpha <= 0) { this.isFadingTapSymbol = false; }
                    }
                },
                reset: function() { this.tapSymbolAlpha = 1.0; this.isFadingTapSymbol = false; }
            };

            const gameOverSequence = {
                step: 0, timer: 0, panelY: canvas.height, panelTargetY: 180, panelSpeed: 15,
                start: function() { this.step = 1; this.timer = 0; score.checkNewBest(); },
                update: function() {
                    if (this.step === 0) return; this.timer++;
                    if (this.step === 1 && this.timer > 30) { this.step = 2; }
                    if (this.step === 2) {
                        this.panelY = Math.max(this.panelTargetY, this.panelY - this.panelSpeed);
                        if (this.panelY === this.panelTargetY) this.step = 3;
                    }
                    if (this.step === 3 && this.timer > 90) { this.step = 4; }
                },
                draw: function() {
                    if (this.step >= 2) { ctx.drawImage(images.gameOver, (canvas.width - ui.titleSize.w) / 2, 120, ui.titleSize.w, ui.titleSize.h); }
                    if (this.step >= 2) { ctx.drawImage(images.uiBackground, (canvas.width - ui.panelSize.w) / 2, this.panelY, ui.panelSize.w, ui.panelSize.h); }
                    if (this.step === 4) {
                        ui.drawPulsingButton(images.replayButton, ui.replayRect, frames, ui.isReplayPressed);
                        ui.drawHomeIcon();
                    }
                },
                reset: function() { this.step = 0; this.timer = 0; this.panelY = canvas.height; }
            };

            const score = {
                best: parseInt(localStorage.getItem('flappybird_best')) || 0, value: 0, newBest: false,
                draw: function() {
                    if (state.current === state.game) { drawTextWithShadow(this.value, canvas.width / 2, 50, "35px 'Arial Black', sans-serif", "center"); }
                    else if (state.current === state.over && gameOverSequence.step >= 2) {
                        drawTextWithShadow("Score", 80, gameOverSequence.panelY + 42, "20px 'Arial Black', sans-serif", "left");
                        drawTextWithShadow("Best", 80, gameOverSequence.panelY + 82, "20px 'Arial Black', sans-serif", "left");
                        drawTextWithShadow(this.value, 210, gameOverSequence.panelY + 42, "20px 'Arial Black', sans-serif", "right");
                        drawTextWithShadow(this.best, 210, gameOverSequence.panelY + 82, "20px 'Arial Black', sans-serif", "right");
                        if(this.newBest && Math.floor(frames / 20) % 2 === 0){ drawTextWithShadow("NEW", 125, gameOverSequence.panelY + 82, "16px 'Arial Black', sans-serif", "left"); }
                    }
                },
                checkNewBest: function() {
                    if (this.value > this.best) {
                        this.best = this.value; localStorage.setItem('flappybird_best', this.best); this.newBest = true;
                    } else {
                        this.newBest = false;
                    }
                },
                reset: function() { this.value = 0; this.newBest = false; }
            };
            
            function drawTextWithShadow(text, x, y, font, align){
                ctx.font = font; ctx.textAlign = align;
                ctx.fillStyle = "#000"; ctx.fillText(text, x + 2, y + 2);
                ctx.fillStyle = "#FFF"; ctx.fillText(text, x, y);
            }

            function getMousePos(canvasEl, evt) {
                const rect = canvasEl.getBoundingClientRect();
                const scaleX = canvasEl.width / rect.width;
                const scaleY = canvasEl.height / rect.height;
                const clientX = evt.clientX || (evt.touches && evt.touches[0].clientX);
                const clientY = evt.clientY || (evt.touches && evt.touches[0].clientY);
                return { x: (clientX - rect.left) * scaleX, y: (clientY - rect.top) * scaleY };
            }
            function isInside(pos, rect) { return pos.x > rect.x && pos.x < rect.x + rect.w && pos.y < rect.y + rect.h && pos.y > rect.y; }

            function handleInput() {
                if (state.current === state.instructions || state.current === state.game) {
                    if (state.current === state.instructions) {
                        ui.isFadingTapSymbol = true;
                        state.current = state.game;
                    }
                    bird.flap(); playSound('flap');
                }
            }
            
            function processClick(evt) {
                if (transition.active) return;
                const pos = getMousePos(canvas, evt);
                
                if (state.current === state.getReady && isInside(pos, ui.backRect)) {
                    playSound('click'); ui.isBackPressed = true; setTimeout(() => { ui.isBackPressed = false; window.location.href = MAIN_HOME_URL; }, 150);
                } else if (state.current === state.getReady && isInside(pos, ui.playRect)) {
                    playSound('click'); ui.isPlayPressed = true;
                    setTimeout(() => { ui.isPlayPressed = false; transition.start(state.instructions); }, 150);
                } else if (state.current === state.over && gameOverSequence.step === 4 && isInside(pos, ui.homeRect)) {
                    playSound('click'); ui.isHomePressed = true;
                    setTimeout(() => { ui.isHomePressed = false; window.location.href = MAIN_HOME_URL; }, 150);
                } else if (state.current === state.over && gameOverSequence.step === 4 && isInside(pos, ui.replayRect)) {
                    playSound('click'); ui.isReplayPressed = true;
                    setTimeout(() => { ui.isReplayPressed = false; transition.start(state.getReady); }, 150);
                } else {
                    handleInput();
                }
            }
            
            canvas.addEventListener('click', processClick);
            canvas.addEventListener('touchstart', (e) => { e.preventDefault(); processClick(e); }, { passive: false });
            
            document.addEventListener('keydown', (e) => { if (e.code === 'Space') handleInput(); });
            
            function resetGame() { bird.reset(); pipes.reset(); score.reset(); ui.reset(); flash.reset(); gameOverSequence.reset(); }
            function update() { bird.update(); pipes.update(); base.update(); ui.update(); transition.update(); flash.update(); gameOverSequence.update(); }
            function draw() { bg.draw(); pipes.draw(); bird.draw(); base.draw(); ui.draw(); score.draw(); flash.draw(); transition.draw(); }

            function loop() {
                update(); draw(); frames++; requestAnimationFrame(loop);
            }
            loop();
        }

        loadAssets();
    </script>
</body>
</html>
