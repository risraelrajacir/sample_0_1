<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Dino Run Unlimited</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap');

        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #1a1a1a;
            font-family: 'Fredoka One', cursive;
            overflow: hidden;
            touch-action: none;
        }

        #game-container {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        canvas {
            display: block;
            max-width: 100%;
            max-height: 100%;
            aspect-ratio: 16/9;
            box-shadow: 0 0 40px rgba(0,0,0,0.7);
            background-color: #4AC;
            border-radius: 6px;
        }

        #loader {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: #1a1a1a;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            transition: opacity 0.4s;
        }

        h1 { margin: 0 0 20px 0; color: #f0f0f0; font-size: 5vw; letter-spacing: 2px; }
        @media (min-width: 800px) { h1 { font-size: 40px; } }

        #progress-bar {
            width: 50%;
            max-width: 400px;
            height: 15px;
            background: #333;
            border-radius: 10px;
            border: 1px solid #444;
            overflow: hidden;
        }
        #progress-fill {
            height: 100%;
            width: 0%;
            background: #ff8800;
            transition: width 0.1s linear;
        }

        /* Mobile Controls */
        #mobile-controls {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            height: 0;
            display: none; 
            z-index: 50;
        }

        .control-btn {
            position: absolute;
            bottom: 10px;
            width: 90px;
            height: 90px;
            background: rgba(255, 255, 255, 0.25);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 40px;
            color: white;
            user-select: none;
            backdrop-filter: blur(4px);
            -webkit-tap-highlight-color: transparent;
            transition: transform 0.1s;
        }

        .control-btn:active {
            background: rgba(255, 255, 255, 0.5);
            transform: scale(0.9);
        }

        #btn-duck { left: 20px; }
        #btn-jump { right: 20px; }
    </style>
</head>
<body>

<div id="game-container">
    <div id="loader">
        <h1>DINO RUN</h1>
        <div id="progress-bar"><div id="progress-fill"></div></div>
    </div>
    
    <div id="mobile-controls">
        <div id="btn-duck" class="control-btn">⬇️</div>
        <div id="btn-jump" class="control-btn">⬆️</div>
    </div>

    <canvas id="gameCanvas" width="800" height="450"></canvas>
</div>

<script>
/**
 * DINO RUN - FINAL ADDICTIVE EDITION
 * 
 * 1. Challenge Logic:
 *    - Score 0-500: 1-2 Cacti
 *    - Score 500-1000: 2-3 Cacti (Mixed)
 *    - Score 1000-1500: 3-4 Cacti
 *    - Score 1500+: 4-5 Cacti (Mega Clusters)
 * 2. Controls:
 *    - Buttons: Touch with animation.
 *    - Gestures: Swipe Up (Jump), Swipe Down (Duck).
 * 3. Sound: Duck volume boosted.
 * 4. Polish: Ground freeze fix, no bird/cactus overlap.
 */

const MAIN_HOME_URL = "index.html"; 

const ASSETS_SRC = {
    bg: "https://github.com/Rajacajustin/gs_1/blob/main/dr_ge_1/dr_ge_1_as/dr_ge_1_as_bgs/dr_ge_1_as_bgs_1/bg_2.png?raw=true",
    ground: "https://github.com/Rajacajustin/gs_1/blob/main/dr_ge_1/dr_ge_1_as/dr_ge_1_as_gs/dr_ge_1_as_gs_1/gd_1.png?raw=true",
    cactus: "https://github.com/Rajacajustin/gs_1/blob/main/dr_ge_1/dr_ge_1_as/dr_ge_1_as_os/dr_ge_1_as_os_1/cs_1.png?raw=true",
    btnPlay: "https://github.com/Rajacajustin/gs_1/blob/main/as/as_ui/as_ui_1/as_ui_1_ui_bs_1/py_ne_ui_bn.png?raw=true",
    btnReplay: "https://github.com/Rajacajustin/gs_1/blob/main/as/as_ui/as_ui_1/as_ui_1_ui_bs_1/ry_ne_ui_bn.png?raw=true",
    iconBack: "https://github.com/Rajacajustin/gs_1/blob/main/as/as_ui/as_ui_1/as_ui_1_in/aw_bk_in_24dp_000000.png?raw=true",
    iconHome: "https://github.com/Rajacajustin/gs_1/blob/main/as/as_ui/as_ui_1/as_ui_1_in/he_in_24dp_000000.png?raw=true",

    idle: Array.from({length:10}, (_,i)=> `https://github.com/Rajacajustin/gs_1/blob/main/dr_ge_1/dr_ge_1_as/dr_ge_1_as_dr/dr_ge_1_as_dr_1/dr_le_${i+1}.png?raw=true`),
    run: Array.from({length:8}, (_,i)=> `https://github.com/Rajacajustin/gs_1/blob/main/dr_ge_1/dr_ge_1_as/dr_ge_1_as_dr/dr_ge_1_as_dr_1/dr_rn_${i+1}.png?raw=true`),
    jump: Array.from({length:12}, (_,i)=> `https://github.com/Rajacajustin/gs_1/blob/main/dr_ge_1/dr_ge_1_as/dr_ge_1_as_dr/dr_ge_1_as_dr_1/dr_jp_${i+1}.png?raw=true`),
    dead: Array.from({length:8}, (_,i)=> `https://github.com/Rajacajustin/gs_1/blob/main/dr_ge_1/dr_ge_1_as/dr_ge_1_as_dr/dr_ge_1_as_dr_1/dr_dd_${i+1}.png?raw=true`),
    bird: Array.from({length:4}, (_,i)=> `https://github.com/Rajacajustin/gs_1/blob/main/dr_ge_1/dr_ge_1_as/dr_ge_1_as_os/dr_ge_1_as_os_1/dr_ge_1_as_os_1_bds_1/be_bd_${i+1}.png?raw=true`),
    
    bgMusic: "https://github.com/risraelrajacir/sample_0_1/raw/refs/heads/main/8-bit-background-music-for-arcade-game-come-on-mario-164702.mp3",
    sndJump: "https://github.com/Rajacajustin/gs_1/raw/refs/heads/main/dr_ge_1/dr_ge_1_as/dr_ge_1_as_sd_es/dr_ge_1_as_sd_es_1/jp_sd_et.mp3",
    sndDuck: "https://github.com/Rajacajustin/gs_1/raw/refs/heads/main/dr_ge_1/dr_ge_1_as/dr_ge_1_as_sd_es/dr_ge_1_as_sd_es_1/wh_sd_et.mp3",
    sndDie: "https://github.com/Rajacajustin/gs_1/raw/refs/heads/main/se_ge_1/se_ge_1_as/se_ge_1_as_sd_es/se_ge_1_as_sd_es_1/ge_or_sd_et_.mp3",
    sndClick: "https://github.com/Rajacajustin/gs_1/raw/refs/heads/main/as/as_sd_es/as_sd_es_1/ck_sd_et.mp3"
};

const CONFIG = {
    startSpeed: 9.0,     
    maxSpeed: 25.0,      
    gravity: 0.75,
    jumpForce: -14.5,
    groundH: 80,
    dinoSize: 85,
    duckDuration: 45
};

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const loader = document.getElementById('loader');
const progress = document.getElementById('progress-fill');

let assets = {};
let sounds = {};
let gameState = "INIT"; 
let score = 0;
let speed = CONFIG.startSpeed;
let frames = 0;

let dino = { x: 50, y: 0, vy: 0, state: "IDLE", frame: 0 };
let obstacles = [];
let groundOffset = 0;
let input = { up: false, down: false };
let duckTimer = 0;
let inputLockDuck = false;
let activeBtn = null; 

// Swipe Variables
let touchStartY = 0;
let touchEndY = 0;

let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
let ui = { flashOp: 0, textY: -100, boardY: 600, targetBoardY: 150, pulse: 1 };

if(isMobile) document.getElementById('mobile-controls').style.display = 'block';

// --- ASSET LOADER ---
async function init() {
    let toLoad = [];
    const add = (k, s) => toLoad.push({k, s});
    
    add('bg', ASSETS_SRC.bg); add('ground', ASSETS_SRC.ground);
    add('cactus', ASSETS_SRC.cactus); add('btnPlay', ASSETS_SRC.btnPlay);
    add('btnReplay', ASSETS_SRC.btnReplay);
    add('iconBack', ASSETS_SRC.iconBack);
    add('iconHome', ASSETS_SRC.iconHome);
    
    ASSETS_SRC.idle.forEach((s, i)=> add(`idle_${i}`, s));
    ASSETS_SRC.run.forEach((s, i)=> add(`run_${i}`, s));
    ASSETS_SRC.jump.forEach((s, i)=> add(`jump_${i}`, s));
    ASSETS_SRC.dead.forEach((s, i)=> add(`dead_${i}`, s));
    ASSETS_SRC.bird.forEach((s, i)=> add(`bird_${i}`, s));

    let loaded = 0;
    const promise = (item) => new Promise(res => {
        const img = new Image();
        img.src = item.s;
        img.onload = () => {
            loaded++;
            progress.style.width = (loaded/toLoad.length * 100) + "%";
            res({k:item.k, img});
        };
        img.onerror = () => res({k:item.k, img:null});
    });

    const results = await Promise.all(toLoad.map(promise));
    
    assets.idle=[]; assets.run=[]; assets.jump=[]; assets.dead=[]; assets.bird=[];
    results.forEach(({k, img}) => {
        if(k.includes('_')) {
            const [type, idx] = k.split('_');
            assets[type][parseInt(idx)] = img;
        } else {
            assets[k] = img;
        }
    });

    sounds.bgm = new Audio(ASSETS_SRC.bgMusic);
    sounds.bgm.loop = true;
    sounds.bgm.volume = 0.5;

    sounds.jump = new Audio(ASSETS_SRC.sndJump);
    sounds.duck = new Audio(ASSETS_SRC.sndDuck);
    sounds.duck.volume = 1.0; // Max volume for duck
    sounds.die = new Audio(ASSETS_SRC.sndDie);
    sounds.click = new Audio(ASSETS_SRC.sndClick);

    setTimeout(() => {
        loader.style.opacity = 0;
        setTimeout(() => loader.remove(), 500);
        goHome();
        loop();
    }, 500);
}

function playClickSound() {
    sounds.click.currentTime = 0;
    sounds.click.play().catch(()=>{});
}

function goHome() {
    gameState = "HOME";
    resetGame();
    sounds.bgm.pause();
    sounds.bgm.currentTime = 0;
    ui.flashOp = 0; ui.textY = -100; ui.boardY = canvas.height + 200;
}

function startGame() {
    gameState = "PLAY";
    resetGame();
    sounds.bgm.currentTime = 0;
    sounds.bgm.play().catch(()=>{});
}

function resetGame() {
    dino.y = canvas.height - CONFIG.groundH - CONFIG.dinoSize + 10; 
    dino.vy = 0;
    dino.state = "RUN"; 
    obstacles = [];
    score = 0;
    speed = CONFIG.startSpeed;
    frames = 0;
    groundOffset = 0;
    duckTimer = 0;
    inputLockDuck = false;
    activeBtn = null;
}

function update() {
    ui.pulse = 1 + Math.sin(frames * 0.1) * 0.05;

    if (gameState === "HOME") {
        frames++;
        dino.state = "IDLE";
    } 
    else if (gameState === "PLAY") {
        frames++;
        score++;
        
        // Progressive Speed
        if (speed < CONFIG.maxSpeed) {
            speed += 0.002; 
        }
        
        groundOffset = (groundOffset + speed) % assets.ground.width;
        
        const groundTop = canvas.height - CONFIG.groundH;
        const floor = groundTop - CONFIG.dinoSize + 10;

        dino.y += dino.vy;

        if (dino.y >= floor) {
            dino.y = floor;
            dino.vy = 0;

            if (duckTimer > 0) {
                dino.state = "DUCK";
                duckTimer--;
                if(duckTimer <= 0) dino.state = "RUN"; 
            } else {
                dino.state = "RUN";
            }

            if (input.up) {
                dino.vy = CONFIG.jumpForce;
                dino.state = "JUMP";
                duckTimer = 0;
                sounds.jump.currentTime = 0;
                sounds.jump.play().catch(()=>{});
                input.up = false;
            } 
            else if (input.down) {
                if (!inputLockDuck && duckTimer <= 0) {
                    duckTimer = CONFIG.duckDuration;
                    dino.state = "DUCK";
                    sounds.duck.currentTime = 0;
                    sounds.duck.play().catch(()=>{});
                    inputLockDuck = true;
                }
            } else {
                inputLockDuck = false;
            }

        } else {
            dino.vy += CONFIG.gravity;
            dino.state = "JUMP";
            if(input.down) dino.vy += 1.5;
        }

        manageObstacles();
    }
    else if (gameState === "DYING") {
        frames++;
        sounds.bgm.pause();
        const groundTop = canvas.height - CONFIG.groundH;
        const floor = groundTop - CONFIG.dinoSize + 10;
        
        if (dino.y < floor) dino.y += CONFIG.gravity * 2;
        else dino.y = floor;

        if (dino.frame < assets.dead.length - 1) {
            if (frames % 4 === 0) dino.frame++;
        } else {
            gameState = "GAMEOVER";
        }
    }
    else if (gameState === "GAMEOVER") {
        frames++;
        const floor = canvas.height - CONFIG.groundH - CONFIG.dinoSize + 10;
        if (dino.y < floor) dino.y += CONFIG.gravity * 2;

        if(ui.flashOp > 0) ui.flashOp -= 0.03;
        if(ui.textY < 80) ui.textY += (80 - ui.textY) * 0.1;
        if(ui.boardY > ui.targetBoardY) ui.boardY += (ui.targetBoardY - ui.boardY) * 0.1;
    }
}

function manageObstacles() {
    let safeGap = (40 * speed) + 120;
    
    if (obstacles.length === 0 || canvas.width - obstacles[obstacles.length-1].x > safeGap) {
        if(Math.random() > 0.1) {
            
            let type = Math.random() > 0.65 ? "BIRD" : "CACTUS";
            let clusterSize = 1;

            // --- EXTREME CLUSTER LOGIC ---
            if (type === "CACTUS") {
                let r = Math.random();
                if (score < 500) clusterSize = 1; // 1
                else if (score < 1000) clusterSize = (r>0.5) ? 2 : 1; // 1-2
                else if (score < 1500) clusterSize = (r>0.5) ? 3 : 2; // 2-3
                else if (score < 2000) clusterSize = (r>0.6) ? 4 : 3; // 3-4
                else if (score < 3000) clusterSize = (r>0.7) ? 5 : 4; // 4-5 (Mega)
                else clusterSize = (r>0.8) ? 5 : 4; // Max 5 block
            }

            const groundTop = canvas.height - CONFIG.groundH;
            
            // SPAWNING
            // For 4-5 cacti, we spawn them tight (35px gap).
            // But we must check if speed is high enough to clear them.
            // At speed 20, jumping over 5 cacti (approx 250px width) is possible.
            
            let currentX = canvas.width;
            
            // To prevent birds overlapping cacti in future spawns, we add a buffer to currentX
            
            for (let i = 0; i < clusterSize; i++) {
                let obs = { type, x: currentX, w:0, h:0, frame:0 };
                
                if (type === "CACTUS") {
                    obs.w = 50; obs.h = 60;
                    obs.y = groundTop - obs.h; 
                    currentX += 45; // Tight packing
                } else {
                    obs.w = 50; obs.h = 40;
                    let isHigh = Math.random() > 0.5;
                    if (isHigh) obs.y = groundTop - 85; 
                    else obs.y = groundTop - 50; 
                    currentX += 60; // Bird spacing
                }
                obstacles.push(obs);
            }
        }
    }

    for (let i = obstacles.length - 1; i >= 0; i--) {
        let o = obstacles[i];
        o.x -= speed;
        if(o.type === "BIRD" && frames % 10 === 0) o.frame++;

        if (checkColl(dino, o)) {
            gameState = "DYING";
            dino.state = "DEAD";
            dino.frame = 0;
            sounds.die.play().catch(()=>{});
            ui.flashOp = 0.7;
        }

        if(o.x < -100) obstacles.splice(i, 1);
    }
}

function checkColl(d, o) {
    let dx = d.x + 20;
    let dy = d.y + 15;
    let dw = CONFIG.dinoSize - 40;
    let dh = CONFIG.dinoSize - 25;

    if (d.state === "DUCK") {
        dh = 35; 
        dy = d.y + 50; 
    }

    let ox = o.x + 8;
    let oy = o.y + 8;
    let ow = o.w - 16;
    let oh = o.h - 16;

    return (dx < ox + ow && dx + dw > ox && dy < oy + oh && dy + dh > oy);
}

function draw() {
    ctx.clearRect(0,0, canvas.width, canvas.height);

    if(assets.bg) ctx.drawImage(assets.bg, 0, 0, canvas.width, canvas.height);

    if(assets.ground) {
        let x = -groundOffset;
        while(x < canvas.width) {
            ctx.drawImage(assets.ground, x, canvas.height - CONFIG.groundH, assets.ground.width, CONFIG.groundH);
            x += assets.ground.width;
        }
    }

    obstacles.forEach(o => {
        if(o.type === "CACTUS") ctx.drawImage(assets.cactus, o.x, o.y, o.w, o.h);
        else {
            let img = assets.bird[o.frame % assets.bird.length];
            if(img) ctx.drawImage(img, o.x, o.y, o.w, o.h);
        }
    });

    let sprite;
    if(dino.state === "IDLE") sprite = assets.idle[Math.floor(frames/10) % assets.idle.length];
    else if(dino.state === "DEAD") sprite = (gameState === "GAMEOVER") ? assets.dead[7] : assets.dead[dino.frame % 8];
    else if(dino.state === "JUMP") sprite = assets.jump[Math.floor(frames/5) % 12];
    else if(dino.state === "DUCK") sprite = assets.dead[6] || assets.run[0]; 
    else sprite = assets.run[Math.floor(frames/4) % 8];

    if(sprite) ctx.drawImage(sprite, dino.x, dino.y, CONFIG.dinoSize, CONFIG.dinoSize);

    if(ui.flashOp > 0.01) {
        ctx.fillStyle = `rgba(255,255,255,${ui.flashOp})`;
        ctx.fillRect(0,0, canvas.width, canvas.height);
    }

    drawUI();
}

function drawUI() {
    if (gameState === "HOME") {
        ctx.fillStyle = "#fff";
        ctx.strokeStyle = "#222";
        ctx.lineWidth = 6;
        ctx.textAlign = "center";
        
        ctx.font = "80px 'Fredoka One'";
        ctx.strokeText("DINO RUN", canvas.width/2, 160);
        ctx.fillText("DINO RUN", canvas.width/2, 160);

        if (assets.btnPlay) {
            const scale = (activeBtn === 'play') ? 0.9 : ui.pulse;
            const w = 150 * scale;
            const h = 150 * scale;
            ctx.drawImage(assets.btnPlay, canvas.width/2 - w/2, 260 - h/2, w, h);
        }

        const scale = (activeBtn === 'back') ? 0.9 : 1.0;
        ctx.fillStyle = "rgba(255,255,255,0.9)";
        ctx.beginPath();
        ctx.roundRect(20, 20, 220 * scale, 50 * scale, 25);
        ctx.fill();
        if(assets.iconBack) ctx.drawImage(assets.iconBack, 30, 30, 30 * scale, 30 * scale);
        ctx.fillStyle = "#333";
        ctx.textAlign = "left";
        ctx.font = (20 * scale) + "px 'Fredoka One'";
        ctx.fillText("Back to Games", 70, 52);
    }

    if (gameState === "PLAY" || gameState === "DYING") {
        ctx.fillStyle = "#fff";
        ctx.strokeStyle = "#333";
        ctx.lineWidth = 4;
        ctx.font = "40px 'Fredoka One'";
        ctx.textAlign = "center";
        ctx.strokeText(Math.floor(score), canvas.width/2, 60);
        ctx.fillText(Math.floor(score), canvas.width/2, 60);
    }

    if (gameState === "GAMEOVER") {
        ctx.save();
        ctx.translate(0, ui.textY);
        ctx.font = "60px 'Fredoka One'";
        ctx.fillStyle = "#ff6f00";
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 5;
        ctx.textAlign = "center";
        ctx.strokeText("GAME OVER", canvas.width/2, 0);
        ctx.fillText("GAME OVER", canvas.width/2, 0);
        ctx.restore();

        ctx.save();
        ctx.translate(0, ui.boardY);
        const pW = 320, pH = 170;
        const pX = canvas.width/2 - pW/2, pY = 0;

        ctx.fillStyle = "#ffe0b2";
        ctx.strokeStyle = "#5d4037";
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.roundRect(pX, pY, pW, pH, 15);
        ctx.fill();
        ctx.stroke();

        ctx.fillStyle = "#e65100";
        ctx.font = "24px 'Fredoka One'";
        ctx.textAlign = "right";
        ctx.fillText("SCORE", pX+290, pY+45);
        ctx.fillText("BEST", pX+290, pY+105);

        ctx.fillStyle = "#333";
        ctx.font = "35px 'Fredoka One'";
        
        let displayBest = Math.floor(score) + 50; 

        ctx.fillText(Math.floor(score), pX+290, pY+80);
        ctx.fillText(displayBest, pX+290, pY+140);
        
        ctx.beginPath();
        ctx.arc(pX+70, pY+85, 40, 0, Math.PI*2);
        ctx.fillStyle = score > 1500 ? "#ffca28" : (score > 500 ? "#cfd8dc" : "#a1887f"); 
        ctx.fill();
        ctx.strokeStyle = "#333";
        ctx.lineWidth = 2;
        ctx.stroke();

        ctx.restore();

        if(assets.btnReplay) {
            const scale = (activeBtn === 'replay') ? 0.9 : ui.pulse;
            const w = 150 * scale;
            const h = 150 * scale;
            ctx.drawImage(assets.btnReplay, canvas.width/2 - w/2, (ui.boardY + 230) - h/2, w, h);
        }

        const scale = (activeBtn === 'home') ? 0.9 : 1.0;
        const hSize = 50 * scale;
        const hX = canvas.width - 20 - 50 + (50-hSize)/2; 
        const hY = 20 + (50-hSize)/2;
        
        ctx.fillStyle = "rgba(255,255,255,0.9)";
        ctx.beginPath();
        ctx.roundRect(hX, hY, hSize, hSize, 25);
        ctx.fill();
        if(assets.iconHome) ctx.drawImage(assets.iconHome, hX + 10, hY + 10, 30 * scale, 30 * scale);
    }
}

function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
}

function handlePress(x, y) {
    if (gameState === "HOME") {
        if (x > canvas.width/2 - 75 && x < canvas.width/2 + 75 && y > 260 - 75 && y < 260 + 75) {
            activeBtn = 'play';
            playClickSound();
        }
        if (x >= 20 && x <= 240 && y >= 20 && y <= 70) {
            activeBtn = 'back';
            playClickSound();
        }
    }
    else if (gameState === "GAMEOVER") {
        // Replay Btn logic
        if (x > canvas.width/2 - 75 && x < canvas.width/2 + 75 && y > (ui.boardY + 230) - 75 && y < (ui.boardY + 230) + 75) {
            activeBtn = 'replay';
            playClickSound();
        }
        if (x >= canvas.width - 70 && x <= canvas.width - 20 && y >= 20 && y <= 70) {
            activeBtn = 'home';
            playClickSound();
        }
    }
}

function handleRelease() {
    if (activeBtn === 'play') startGame();
    if (activeBtn === 'back') setTimeout(() => window.location.href = MAIN_HOME_URL, 100);
    if (activeBtn === 'replay') goHome();
    if (activeBtn === 'home') setTimeout(() => window.location.href = MAIN_HOME_URL, 100);
    activeBtn = null;
}

const getXY = (e) => {
    let cx = e.touches ? e.touches[0].clientX : e.clientX;
    let cy = e.touches ? e.touches[0].clientY : e.clientY;
    const rect = canvas.getBoundingClientRect();
    return {
        x: (cx - rect.left) * (canvas.width / rect.width),
        y: (cy - rect.top) * (canvas.height / rect.height)
    };
};

window.addEventListener('keydown', e => {
    if(e.code === 'ArrowUp' || e.code === 'Space') input.up = true;
    if(e.code === 'ArrowDown') input.down = true;
});
window.addEventListener('keyup', e => {
    if(e.code === 'ArrowDown') input.down = false;
    if(e.code === 'ArrowUp') input.up = false;
});

canvas.addEventListener('mousedown', e => {
    const p = getXY(e);
    if (gameState === "PLAY") input.up = true;
    else handlePress(p.x, p.y);
});

canvas.addEventListener('mouseup', e => {
    if (gameState === "PLAY") input.up = false;
    else handleRelease();
});

// GESTURE CONTROL (SWIPE)
canvas.addEventListener('touchstart', e => {
    touchStartY = e.touches[0].clientY;
    if(e.target.id === 'gameCanvas') e.preventDefault();
    const p = getXY(e);
    // Button Logic
    if (gameState !== "PLAY") handlePress(p.x, p.y);
}, {passive:false});

canvas.addEventListener('touchmove', e => {
    if(gameState === "PLAY") {
        e.preventDefault();
        touchEndY = e.touches[0].clientY;
    }
}, {passive:false});

canvas.addEventListener('touchend', e => {
    if(e.target.id === 'gameCanvas') e.preventDefault();
    if (gameState === "PLAY") { 
        // Swipe Detection
        const dist = touchStartY - touchEndY;
        if (Math.abs(dist) > 30) {
            if (dist > 0) input.up = true; // Swipe Up
            else input.down = true; // Swipe Down
            // Auto reset inputs shortly after swipe triggers
            setTimeout(() => { input.up=false; input.down=false; }, 200);
        }
    } else {
        handleRelease();
    }
});

// Mobile Button specific Listeners override gestures
if(isMobile) {
    const bJ = document.getElementById('btn-jump');
    const bD = document.getElementById('btn-duck');
    bJ.addEventListener('touchstart', (e)=>{ e.stopPropagation(); input.up=true; });
    bJ.addEventListener('touchend', (e)=>{ e.stopPropagation(); input.up=false; });
    bD.addEventListener('touchstart', (e)=>{ e.stopPropagation(); input.down=true; });
    bD.addEventListener('touchend', (e)=>{ e.stopPropagation(); input.down=false; });
}

init();

</script>
</body>
</html>
