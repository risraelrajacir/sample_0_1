<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Dino Run Unlimited</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Bangers&display=swap');

        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #1a1a1a;
            font-family: 'Fredoka One', cursive;
            overflow: hidden;
            touch-action: none;
            -webkit-tap-highlight-color: transparent;
            /* Disable text selection everywhere */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            cursor: default;
        }

        #game-container {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        canvas {
            display: block;
            max-width: 100%;
            max-height: 100%;
            aspect-ratio: 16/9;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            background-color: #4AC;
            border-radius: 6px;
        }

        /* --- LOADER --- */
        #loader {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: #1a1a1a;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            transition: opacity 0.4s;
        }

        h1 { 
            margin: 0 0 10px 0; 
            color: #FFD700;
            font-size: 6vw; 
            letter-spacing: 2px;
            text-transform: uppercase;
            text-shadow: 4px 4px 0 #000;
            font-style: italic;
        }
        @media (min-width: 800px) { h1 { font-size: 60px; } }

        #progress-bar-bg {
            width: 60%;
            max-width: 400px;
            height: 20px;
            background: #333;
            border-radius: 10px;
            border: 2px solid #555;
            overflow: hidden;
            margin-bottom: 10px;
        }
        #progress-fill {
            height: 100%;
            width: 0%;
            background: #ff8800;
            transition: width 0.1s linear;
        }
        #loading-text {
            color: #888;
            font-size: 18px;
            letter-spacing: 1px;
        }

        /* --- COUNTDOWN --- */
        #countdown {
            position: absolute; 
            top: 50%; 
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Bangers', cursive; 
            color: #FFD700;
            text-shadow: 5px 5px 15px rgba(0,0,0,0.6);
            display: none; 
            font-size: 10rem;
            pointer-events: none; /* No interaction */
            z-index: 60;
            white-space: nowrap;
        }
        
        @keyframes countdown-zoom-fade { 
            from { transform: translate(-50%, -50%) scale(0.5); opacity: 0; } 
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); } 
            to { transform: translate(-50%, -50%) scale(1.5); opacity: 0; } 
        }

        /* --- CONTROLS --- */
        #mobile-controls {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            height: 0;
            display: none; 
            z-index: 50;
        }

        .control-btn {
            position: absolute;
            bottom: 10px;
            width: 90px;
            height: 90px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 40px;
            color: white;
            backdrop-filter: blur(4px);
            transition: transform 0.1s ease, background 0.1s ease;
            -webkit-user-select: none;
        }

        /* Active state for Click Animation */
        .control-btn.active-press {
            transform: scale(0.90);
            background: rgba(255, 255, 255, 0.5);
        }

        #btn-duck { left: 20px; }
        #btn-jump { right: 20px; }
    </style>
</head>
<body>

<div id="game-container">
    <div id="loader">
        <h1>DINO RUN</h1>
        <div id="progress-bar-bg"><div id="progress-fill"></div></div>
        <div id="loading-text">Loading...</div>
    </div>

    <div id="countdown"></div>

    <div id="mobile-controls">
        <div id="btn-duck" class="control-btn">⬇️</div>
        <div id="btn-jump" class="control-btn">⬆️</div>
    </div>

    <canvas id="gameCanvas" width="800" height="450"></canvas>
</div>

<script>
/**
 * DINO RUN - ULTIMATE EDITION
 * 
 * Corrections & Features:
 * 1. Spawning: Strict score-based cluster sizes (1 to 5).
 * 2. Tight Units: 4-5 Cacti spawn closer together (Mega Cluster).
 * 3. Birds: Separated logic, never attach to cacti.
 * 4. Controls: 
 *    - Arrows: Visual click animation.
 *    - Swipe: True Up/Down swipe gestures.
 *    - No Click Sound on Arrows.
 * 5. UI: No text cursors anywhere.
 */

const MAIN_HOME_URL = "index.html"; 

const ASSETS_SRC = {
    bg: "https://github.com/Rajacajustin/gs_1/blob/main/dr_ge_1/dr_ge_1_as/dr_ge_1_as_bgs/dr_ge_1_as_bgs_1/bg_1.png?raw=true",
    ground: "https://github.com/Rajacajustin/gs_1/blob/main/dr_ge_1/dr_ge_1_as/dr_ge_1_as_gs/dr_ge_1_as_gs_1/gd_1.png?raw=true",
    cactus: "https://github.com/Rajacajustin/gs_1/blob/main/dr_ge_1/dr_ge_1_as/dr_ge_1_as_os/dr_ge_1_as_os_1/cs_1.png?raw=true",
    btnPlay: "https://github.com/Rajacajustin/gs_1/blob/main/as/as_ui/as_ui_1/as_ui_1_ui_bs_1/py_ne_ui_bn.png?raw=true",
    btnReplay: "https://github.com/Rajacajustin/gs_1/blob/main/as/as_ui/as_ui_1/as_ui_1_ui_bs_1/ry_ne_ui_bn.png?raw=true",
    iconBack: "https://github.com/Rajacajustin/gs_1/blob/main/as/as_ui/as_ui_1/as_ui_1_in/aw_bk_in_24dp_000000.png?raw=true",
    iconHome: "https://github.com/Rajacajustin/gs_1/blob/main/as/as_ui/as_ui_1/as_ui_1_in/he_in_24dp_000000.png?raw=true",

    idle: Array.from({length:10}, (_,i)=> `https://github.com/Rajacajustin/gs_1/blob/main/dr_ge_1/dr_ge_1_as/dr_ge_1_as_dr/dr_ge_1_as_dr_1/dr_le_${i+1}.png?raw=true`),
    run: Array.from({length:8}, (_,i)=> `https://github.com/Rajacajustin/gs_1/blob/main/dr_ge_1/dr_ge_1_as/dr_ge_1_as_dr/dr_ge_1_as_dr_1/dr_rn_${i+1}.png?raw=true`),
    jump: Array.from({length:12}, (_,i)=> `https://github.com/Rajacajustin/gs_1/blob/main/dr_ge_1/dr_ge_1_as/dr_ge_1_as_dr/dr_ge_1_as_dr_1/dr_jp_${i+1}.png?raw=true`),
    dead: Array.from({length:8}, (_,i)=> `https://github.com/Rajacajustin/gs_1/blob/main/dr_ge_1/dr_ge_1_as/dr_ge_1_as_dr/dr_ge_1_as_dr_1/dr_dd_${i+1}.png?raw=true`),
    bird: Array.from({length:4}, (_,i)=> `https://github.com/Rajacajustin/gs_1/blob/main/dr_ge_1/dr_ge_1_as/dr_ge_1_as_os/dr_ge_1_as_os_1/dr_ge_1_as_os_1_bds_1/be_bd_${i+1}.png?raw=true`),
    
    bgMusic: "https://github.com/risraelrajacir/sample_0_1/raw/refs/heads/main/8-bit-background-music-for-arcade-game-come-on-mario-164702.mp3",
    sndJump: "https://github.com/Rajacajustin/gs_1/raw/refs/heads/main/dr_ge_1/dr_ge_1_as/dr_ge_1_as_sd_es/dr_ge_1_as_sd_es_1/jp_sd_et.mp3",
    sndDuck: "https://github.com/Rajacajustin/gs_1/raw/refs/heads/main/dr_ge_1/dr_ge_1_as/dr_ge_1_as_sd_es/dr_ge_1_as_sd_es_1/we_se_dn_sd_et.mp3",
    sndDie: "https://github.com/Rajacajustin/gs_1/raw/refs/heads/main/se_ge_1/se_ge_1_as/se_ge_1_as_sd_es/se_ge_1_as_sd_es_1/ge_or_sd_et_.mp3",
    sndClick: "https://github.com/Rajacajustin/gs_1/raw/refs/heads/main/as/as_sd_es/as_sd_es_1/ck_sd_et.mp3",
    sndCountdown: "https://github.com/Rajacajustin/gs_1/raw/refs/heads/main/as/as_sd_es/as_sd_es_1/st_bp_ctdn_sd_et.mp3"
};

const CONFIG = {
    startSpeed: 8.5,     
    maxSpeed: 26.0,      
    gravity: 0.75,
    jumpForce: -14.5,
    groundH: 80,
    dinoSize: 85,
    duckDuration: 45
};

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const loader = document.getElementById('loader');
const progress = document.getElementById('progress-fill');
const countdownEl = document.getElementById('countdown');

let assets = {};
let sounds = {};
let gameState = "INIT"; 
let score = 0;
let sessionBest = 0; 
let speed = CONFIG.startSpeed;
let frames = 0;

let dino = { x: 50, y: 0, vy: 0, state: "IDLE", frame: 0 };
let obstacles = [];
let groundOffset = 0; 
let frozenGroundOffset = 0;
let input = { up: false, down: false };
let duckTimer = 0;
let inputLockDuck = false;

// UI State
let activeBtn = null; 
let hoverBtn = null;  

// Swipe Vars
let touchStartY = 0;
let touchEndY = 0;

let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
let ui = { flashOp: 0, textY: -100, boardY: 600, targetBoardY: 150 };

if(isMobile) document.getElementById('mobile-controls').style.display = 'block';

// --- ASSET LOADER ---
async function init() {
    let toLoad = [];
    const add = (k, s) => toLoad.push({k, s});
    
    add('bg', ASSETS_SRC.bg); add('ground', ASSETS_SRC.ground);
    add('cactus', ASSETS_SRC.cactus); add('btnPlay', ASSETS_SRC.btnPlay);
    add('btnReplay', ASSETS_SRC.btnReplay);
    add('iconBack', ASSETS_SRC.iconBack);
    add('iconHome', ASSETS_SRC.iconHome);
    
    ASSETS_SRC.idle.forEach((s, i)=> add(`idle_${i}`, s));
    ASSETS_SRC.run.forEach((s, i)=> add(`run_${i}`, s));
    ASSETS_SRC.jump.forEach((s, i)=> add(`jump_${i}`, s));
    ASSETS_SRC.dead.forEach((s, i)=> add(`dead_${i}`, s));
    ASSETS_SRC.bird.forEach((s, i)=> add(`bird_${i}`, s));

    let loaded = 0;
    const promise = (item) => new Promise(res => {
        const img = new Image();
        img.src = item.s;
        img.onload = () => {
            loaded++;
            progress.style.width = (loaded/toLoad.length * 100) + "%";
            res({k:item.k, img});
        };
        img.onerror = () => res({k:item.k, img:null});
    });

    const results = await Promise.all(toLoad.map(promise));
    
    assets.idle=[]; assets.run=[]; assets.jump=[]; assets.dead=[]; assets.bird=[];
    results.forEach(({k, img}) => {
        if(k.includes('_')) {
            const [type, idx] = k.split('_');
            assets[type][parseInt(idx)] = img;
        } else {
            assets[k] = img;
        }
    });

    sounds.bgm = new Audio(ASSETS_SRC.bgMusic);
    sounds.bgm.loop = true;
    sounds.bgm.volume = 0.5;

    sounds.jump = new Audio(ASSETS_SRC.sndJump);
    sounds.duck = new Audio(ASSETS_SRC.sndDuck);
    sounds.duck.volume = 1.0; 
    sounds.die = new Audio(ASSETS_SRC.sndDie);
    sounds.click = new Audio(ASSETS_SRC.sndClick);
    sounds.countdown = new Audio(ASSETS_SRC.sndCountdown);

    setTimeout(() => {
        loader.style.opacity = 0;
        setTimeout(() => loader.remove(), 500);
        goHome();
        loop();
    }, 500);
}

function playClick() {
    sounds.click.currentTime = 0;
    sounds.click.play().catch(()=>{});
}

function goHome() {
    gameState = "HOME";
    resetGameData();
    sounds.bgm.pause();
    sounds.bgm.currentTime = 0;
    ui.flashOp = 0; ui.textY = -100; ui.boardY = canvas.height + 200;
}

function resetGameData() {
    dino.y = canvas.height - CONFIG.groundH - CONFIG.dinoSize + 10; 
    dino.vy = 0;
    dino.state = "RUN"; 
    obstacles = [];
    score = 0;
    speed = CONFIG.startSpeed;
    frames = 0;
    groundOffset = 0;
    frozenGroundOffset = 0;
    duckTimer = 0;
    inputLockDuck = false;
    activeBtn = null;
    hoverBtn = null;
    input.up = false;
    input.down = false;
}

// --- COUNTDOWN LOGIC ---
function startCountdown() {
    gameState = "COUNTDOWN";
    resetGameData(); 
    ui.flashOp = 0; ui.textY = -100; ui.boardY = canvas.height + 200;
    
    sounds.bgm.pause();
    sounds.bgm.currentTime = 0;
    
    // Play sound immediately
    sounds.countdown.currentTime = 0;
    sounds.countdown.play().catch(()=>{});

    const showText = (txt) => {
        countdownEl.innerText = txt;
        countdownEl.style.display = 'block';
        // Restart Animation
        countdownEl.style.animation = 'none';
        countdownEl.offsetHeight; 
        countdownEl.style.animation = 'countdown-zoom-fade 1s ease-in-out forwards';
    };

    // 3, 2, 1, GO Sequence
    showText("3");
    setTimeout(() => showText("2"), 1000);
    setTimeout(() => showText("1"), 2000);
    setTimeout(() => showText("GO!!"), 3000);

    setTimeout(() => {
        countdownEl.style.display = 'none';
        startGameplay();
    }, 4000);
}

function startGameplay() {
    gameState = "PLAY";
    sounds.bgm.play().catch(()=>{});
}

function update() {
    if (gameState === "HOME" || gameState === "COUNTDOWN") {
        frames++;
        dino.state = "IDLE";
    } 
    
    else if (gameState === "PLAY") {
        frames++;
        score++;
        
        // Smooth Speed Increase
        if (speed < CONFIG.maxSpeed) {
            speed += 0.002; 
        }
        
        groundOffset = (groundOffset + speed) % assets.ground.width;
        
        const groundTop = canvas.height - CONFIG.groundH;
        const floor = groundTop - CONFIG.dinoSize + 10;

        dino.y += dino.vy;

        if (dino.y >= floor) {
            dino.y = floor;
            dino.vy = 0;

            if (duckTimer > 0) {
                dino.state = "DUCK";
                duckTimer--;
                if(duckTimer <= 0) dino.state = "RUN"; 
            } else {
                dino.state = "RUN";
            }

            if (input.up) {
                dino.vy = CONFIG.jumpForce;
                dino.state = "JUMP";
                duckTimer = 0;
                sounds.jump.currentTime = 0;
                sounds.jump.play().catch(()=>{});
                input.up = false;
            } 
            else if (input.down) {
                if (!inputLockDuck && duckTimer <= 0) {
                    duckTimer = CONFIG.duckDuration;
                    dino.state = "DUCK";
                    sounds.duck.currentTime = 0;
                    sounds.duck.play().catch(()=>{});
                    inputLockDuck = true;
                }
            } else {
                inputLockDuck = false;
            }

        } else {
            dino.vy += CONFIG.gravity;
            dino.state = "JUMP";
            if(input.down) dino.vy += 1.5;
        }

        manageObstacles();
    }

    else if (gameState === "DYING") {
        frames++;
        sounds.bgm.pause();
        const groundTop = canvas.height - CONFIG.groundH;
        const floor = groundTop - CONFIG.dinoSize + 10;
        
        if (dino.y < floor) dino.y += CONFIG.gravity * 2;
        else dino.y = floor;

        if (dino.frame < assets.dead.length - 1) {
            if (frames % 4 === 0) dino.frame++;
        } else {
            gameState = "GAMEOVER";
            if (score > sessionBest) sessionBest = score;
        }
    }

    else if (gameState === "GAMEOVER") {
        const floor = canvas.height - CONFIG.groundH - CONFIG.dinoSize + 10;
        if (dino.y < floor) dino.y += CONFIG.gravity * 2;

        if(ui.flashOp > 0) ui.flashOp -= 0.03;
        if(ui.textY < 80) ui.textY += (80 - ui.textY) * 0.1;
        if(ui.boardY > ui.targetBoardY) ui.boardY += (ui.targetBoardY - ui.boardY) * 0.1;
    }
}

function manageObstacles() {
    // Distance between obstacle groups
    let safeGap = (45 * speed) + 150;
    
    if (obstacles.length === 0 || canvas.width - obstacles[obstacles.length-1].x > safeGap) {
        if(Math.random() > 0.1) { // 90% spawn chance
            
            // Decider: Bird or Cactus?
            // High score -> More birds
            let birdChance = score > 500 ? 0.35 : 0; 
            let type = Math.random() < birdChance ? "BIRD" : "CACTUS";
            let clusterSize = 1;

            // --- STRICT SCORE-BASED CLUSTER LOGIC ---
            if (type === "CACTUS") {
                let r = Math.random();
                // 0-500: Always 1
                if (score < 500) {
                    clusterSize = 1;
                }
                // 500-1000: 1 or 2
                else if (score < 1000) {
                    clusterSize = (r > 0.5) ? 2 : 1;
                }
                // 1000-1500: 1, 2, or 3
                else if (score < 1500) {
                    if (r > 0.6) clusterSize = 3;
                    else if (r > 0.3) clusterSize = 2;
                    else clusterSize = 1;
                }
                // 1500-2000: 1, 2, 3, or 4
                else if (score < 2000) {
                    if (r > 0.75) clusterSize = 4;
                    else if (r > 0.5) clusterSize = 3;
                    else if (r > 0.25) clusterSize = 2;
                    else clusterSize = 1;
                }
                // 2000+: 1, 2, 3, 4, or 5 (Max Challenge)
                else {
                    if (r > 0.8) clusterSize = 5;
                    else if (r > 0.6) clusterSize = 4;
                    else if (r > 0.4) clusterSize = 3;
                    else if (r > 0.2) clusterSize = 2;
                    else clusterSize = 1;
                }
            } 
            else {
                // Birds don't form large clusters, usually single
                clusterSize = 1; 
            }

            const groundTop = canvas.height - CONFIG.groundH;
            let currentX = canvas.width;

            // --- GENERATE THE CLUSTER ---
            for(let i=0; i<clusterSize; i++) {
                let obs = { type, x: currentX, w:0, h:0, frame:0 };
                
                if (type === "CACTUS") {
                    obs.w = 50; obs.h = 60;
                    obs.y = groundTop - obs.h; 
                    
                    // TIGHT UNIT LOGIC:
                    // If cluster size is large (3,4,5), overlap them more to make a "Mega Cluster"
                    // Normal spacing is ~50. For tight unit, use 30 or 40.
                    let overlap = (clusterSize >= 4) ? 35 : 45;
                    currentX += overlap; 
                } else {
                    obs.w = 50; obs.h = 40;
                    // Bird Heights
                    let isHigh = Math.random() > 0.5;
                    if (isHigh) obs.y = groundTop - 85; 
                    else obs.y = groundTop - 50; 
                    
                    currentX += 60; 
                }
                obstacles.push(obs);
            }
        }
    }

    // Move & Cleanup
    for (let i = obstacles.length - 1; i >= 0; i--) {
        let o = obstacles[i];
        o.x -= speed;
        if(o.type === "BIRD" && frames % 10 === 0) o.frame++;

        if (checkColl(dino, o)) {
            gameState = "DYING";
            dino.state = "DEAD";
            dino.frame = 0;
            frozenGroundOffset = groundOffset;
            sounds.die.play().catch(()=>{});
            ui.flashOp = 0.7;
        }

        if(o.x < -100) obstacles.splice(i, 1);
    }
}

function checkColl(d, o) {
    let dx = d.x + 20;
    let dy = d.y + 15;
    let dw = CONFIG.dinoSize - 40;
    let dh = CONFIG.dinoSize - 25;

    if (d.state === "DUCK") {
        dh = 35; 
        dy = d.y + 50; 
    }

    let ox = o.x + 8;
    let oy = o.y + 8;
    let ow = o.w - 16;
    let oh = o.h - 16;

    return (dx < ox + ow && dx + dw > ox && dy < oy + oh && dy + dh > oy);
}

function draw() {
    ctx.clearRect(0,0, canvas.width, canvas.height);

    if(assets.bg) ctx.drawImage(assets.bg, 0, 0, canvas.width, canvas.height);

    if(assets.ground) {
        let offsetToUse = (gameState === "DYING" || gameState === "GAMEOVER") ? frozenGroundOffset : groundOffset;
        let x = -offsetToUse;
        while(x < canvas.width) {
            ctx.drawImage(assets.ground, x, canvas.height - CONFIG.groundH, assets.ground.width, CONFIG.groundH);
            x += assets.ground.width;
        }
    }

    obstacles.forEach(o => {
        if(o.type === "CACTUS") ctx.drawImage(assets.cactus, o.x, o.y, o.w, o.h);
        else {
            let img = assets.bird[o.frame % assets.bird.length];
            if(img) ctx.drawImage(img, o.x, o.y, o.w, o.h);
        }
    });

    let sprite;
    if(dino.state === "IDLE") sprite = assets.idle[Math.floor(frames/10) % assets.idle.length];
    else if(dino.state === "DEAD") sprite = (gameState === "GAMEOVER") ? assets.dead[7] : assets.dead[dino.frame % 8];
    else if(dino.state === "JUMP") sprite = assets.jump[Math.floor(frames/5) % 12];
    else if(dino.state === "DUCK") sprite = assets.dead[6] || assets.run[0]; 
    else sprite = assets.run[Math.floor(frames/4) % 8];

    if(sprite) ctx.drawImage(sprite, dino.x, dino.y, CONFIG.dinoSize, CONFIG.dinoSize);

    if(ui.flashOp > 0.01) {
        ctx.fillStyle = `rgba(255,255,255,${ui.flashOp})`;
        ctx.fillRect(0,0, canvas.width, canvas.height);
    }

    drawUI();
}

function getScale(btnName) {
    if (isMobile) {
        return (activeBtn === btnName) ? 0.94 : 1.0;
    } 
    else {
        if (activeBtn === btnName) return 0.94;
        if (hoverBtn === btnName) return 1.03;
        return 1.0;
    }
}

function drawUI() {
    if (gameState === "HOME") {
        ctx.fillStyle = "#fff";
        ctx.strokeStyle = "#222";
        ctx.lineWidth = 6;
        ctx.textAlign = "center";
        
        ctx.font = "80px 'Fredoka One'";
        ctx.strokeText("DINO RUN", canvas.width/2, 160);
        ctx.fillText("DINO RUN", canvas.width/2, 160);

        if (assets.btnPlay) {
            const scale = getScale('play');
            const w = 150 * scale;
            const h = 150 * scale;
            ctx.drawImage(assets.btnPlay, canvas.width/2 - w/2, 260 - h/2, w, h);
        }

        const scaleB = getScale('back');
        ctx.fillStyle = "rgba(255,255,255,0.9)";
        ctx.beginPath();
        ctx.roundRect(20, 20, 220 * scaleB, 50 * scaleB, 25);
        ctx.fill();
        if(assets.iconBack) ctx.drawImage(assets.iconBack, 30, 30, 30 * scaleB, 30 * scaleB);
        ctx.fillStyle = "#333";
        ctx.textAlign = "left";
        ctx.font = (20 * scaleB) + "px 'Fredoka One'";
        ctx.fillText("Back to Games", 70, 52);
    }

    if (gameState === "PLAY" || gameState === "DYING" || gameState === "COUNTDOWN") {
        ctx.fillStyle = "#fff";
        ctx.strokeStyle = "#333";
        ctx.lineWidth = 4;
        ctx.font = "40px 'Fredoka One'";
        ctx.textAlign = "center";
        let dScore = Math.floor(score);
        ctx.strokeText(dScore, canvas.width/2, 60);
        ctx.fillText(dScore, canvas.width/2, 60);
    }

    if (gameState === "GAMEOVER") {
        ctx.save();
        ctx.translate(0, ui.textY);
        ctx.font = "60px 'Fredoka One'";
        ctx.fillStyle = "#ff6f00";
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 5;
        ctx.textAlign = "center";
        ctx.strokeText("GAME OVER", canvas.width/2, 0);
        ctx.fillText("GAME OVER", canvas.width/2, 0);
        ctx.restore();

        ctx.save();
        ctx.translate(0, ui.boardY);
        const pW = 320, pH = 170;
        const pX = canvas.width/2 - pW/2, pY = 0;

        ctx.fillStyle = "#ffe0b2";
        ctx.strokeStyle = "#5d4037";
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.roundRect(pX, pY, pW, pH, 15);
        ctx.fill();
        ctx.stroke();

        ctx.fillStyle = "#e65100";
        ctx.font = "24px 'Fredoka One'";
        ctx.textAlign = "right";
        ctx.fillText("SCORE", pX+290, pY+45);
        ctx.fillText("BEST", pX+290, pY+105);

        ctx.fillStyle = "#333";
        ctx.font = "35px 'Fredoka One'";
        
        let displayBest = Math.max(score, sessionBest);

        ctx.fillText(Math.floor(score), pX+290, pY+80);
        ctx.fillText(Math.floor(displayBest), pX+290, pY+140);
        
        ctx.beginPath();
        ctx.arc(pX+70, pY+85, 40, 0, Math.PI*2);
        ctx.fillStyle = score > 1500 ? "#ffca28" : (score > 500 ? "#cfd8dc" : "#a1887f"); 
        ctx.fill();
        ctx.strokeStyle = "#333";
        ctx.lineWidth = 2;
        ctx.stroke();

        ctx.restore();

        if(assets.btnReplay) {
            const scale = getScale('replay');
            const w = 150 * scale;
            const h = 150 * scale;
            ctx.drawImage(assets.btnReplay, canvas.width/2 - w/2, (ui.boardY + 230) - h/2, w, h);
        }

        const scaleH = getScale('home');
        const hSize = 50 * scaleH;
        const hX = canvas.width - 20 - 50 + (50-hSize)/2; 
        const hY = 20 + (50-hSize)/2;
        
        ctx.fillStyle = "rgba(255,255,255,0.9)";
        ctx.beginPath();
        ctx.roundRect(hX, hY, hSize, hSize, 25);
        ctx.fill();
        if(assets.iconHome) ctx.drawImage(assets.iconHome, hX + 10, hY + 10, 30 * scaleH, 30 * scaleH);
    }
}

// --- INPUT & INTERACTION ---
function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
}

const getXY = (e) => {
    let cx = e.touches ? e.touches[0].clientX : e.clientX;
    let cy = e.touches ? e.touches[0].clientY : e.clientY;
    const rect = canvas.getBoundingClientRect();
    return {
        x: (cx - rect.left) * (canvas.width / rect.width),
        y: (cy - rect.top) * (canvas.height / rect.height)
    };
};

// UI Button Hitbox
function checkButtons(x, y) {
    if (gameState === "HOME") {
        if (x > canvas.width/2 - 75 && x < canvas.width/2 + 75 && y > 185 && y < 335) return 'play';
        if (x >= 20 && x <= 240 && y >= 20 && y <= 70) return 'back';
    }
    else if (gameState === "GAMEOVER") {
        if (x > canvas.width/2 - 75 && x < canvas.width/2 + 75 && y > (ui.boardY + 230) - 75 && y < (ui.boardY + 230) + 75) return 'replay';
        if (x >= canvas.width - 70 && x <= canvas.width - 20 && y >= 20 && y <= 70) return 'home';
    }
    return null;
}

function onInteractStart(x, y) {
    const target = checkButtons(x, y);
    if (target) {
        activeBtn = target;
        playClick(); 
    } else {
        // Game interaction only if PLAY (Tap to Jump)
        if (gameState === "PLAY") input.up = true;
    }
}

function onInteractEnd() {
    if (activeBtn) {
        if (activeBtn === 'play') startCountdown();
        if (activeBtn === 'back') setTimeout(() => window.location.href = MAIN_HOME_URL, 100);
        if (activeBtn === 'replay') startCountdown();
        if (activeBtn === 'home') setTimeout(() => window.location.href = MAIN_HOME_URL, 100);
    }
    activeBtn = null;
    input.up = false;
}

// PC Hover
canvas.addEventListener('mousemove', e => {
    if(!isMobile) {
        const p = getXY(e);
        hoverBtn = checkButtons(p.x, p.y);
        canvas.style.cursor = hoverBtn ? 'pointer' : 'default';
    }
});

canvas.addEventListener('mousedown', e => {
    const p = getXY(e);
    onInteractStart(p.x, p.y);
});
canvas.addEventListener('mouseup', onInteractEnd);

// Touch Logic
canvas.addEventListener('touchstart', e => {
    if(e.target.id === 'gameCanvas') e.preventDefault();
    const p = getXY(e);
    touchStartY = p.y;
    onInteractStart(p.x, p.y);
}, {passive:false});

canvas.addEventListener('touchmove', e => {
    if(gameState === "PLAY") e.preventDefault();
    const p = getXY(e);
    touchEndY = p.y;
}, {passive:false});

canvas.addEventListener('touchend', e => {
    if(e.target.id === 'gameCanvas') e.preventDefault();
    
    // --- TRUE SWIPE SUPPORT ---
    if (gameState === "PLAY") {
        const dist = touchStartY - touchEndY;
        // Threshold of 30px for a swipe
        if (Math.abs(dist) > 30) { 
            if (dist > 0) { // Swipe Up
                input.up = true;
                input.down = false;
            } 
            else { // Swipe Down
                input.down = true;
                input.up = false;
            }
            
            // Auto reset input shortly after swipe to allow repetitive swipes
            setTimeout(() => { 
                input.up=false; 
                input.down=false; 
            }, 200);
        }
    }
    
    onInteractEnd();
});

// Mobile On-Screen Controls (Visual Animation + No Sound)
if(isMobile) {
    const btnJ = document.getElementById('btn-jump');
    const btnD = document.getElementById('btn-duck');
    
    btnJ.addEventListener('touchstart', (e)=>{ 
        e.preventDefault(); e.stopPropagation(); 
        input.up=true; 
        btnJ.classList.add('active-press'); // Visual
    });
    btnJ.addEventListener('touchend', (e)=>{ 
        e.preventDefault(); 
        input.up=false; 
        btnJ.classList.remove('active-press'); 
    });
    
    btnD.addEventListener('touchstart', (e)=>{ 
        e.preventDefault(); e.stopPropagation(); 
        input.down=true; 
        btnD.classList.add('active-press'); // Visual
    });
    btnD.addEventListener('touchend', (e)=>{ 
        e.preventDefault(); 
        input.down=false; 
        btnD.classList.remove('active-press'); 
    });
}

// Keyboard
window.addEventListener('keydown', e => {
    if(gameState === "PLAY") {
        if(e.code === 'ArrowUp' || e.code === 'Space') input.up = true;
        if(e.code === 'ArrowDown') input.down = true;
    }
});
window.addEventListener('keyup', e => {
    if(e.code === 'ArrowDown') input.down = false;
    if(e.code === 'ArrowUp') input.up = false;
});

init();

</script>
</body>
</html>
